{"meta":{"title":"Don't forget","subtitle":"lazy","description":null,"author":"Hae Jin","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"이클립스 한글 인코딩(UTF-8) 환경 설정","slug":"setting-encode","date":"2018-08-27T14:58:04.000Z","updated":"2018-08-29T15:04:27.249Z","comments":true,"path":"2018/08/27/setting-encode/","link":"","permalink":"http://yoursite.com/2018/08/27/setting-encode/","excerpt":"","text":"웹에서는 EUC-KR 이나 UTF-8을 많이 사용한다. Window - Preferences 선택 후 General 항목- Workspace 항목- 하단의 Text file encoding의&nbsp;&nbsp;&nbsp;&nbsp;Other: UTF-8 설정 Web 항목- CSS Files- HTML Files- JSP FIles세가지 항목 모두 ISO 10646/Unicode(UTF-8) 로 설정 위와같이 1,2 설정을 해준다.","categories":[{"name":"Programing","slug":"Programing","permalink":"http://yoursite.com/categories/Programing/"}],"tags":[]},{"title":"HTML 파일명의 대소문자만 바꾸는 경우","slug":"filename-case","date":"2018-08-27T14:52:40.000Z","updated":"2018-08-29T14:56:23.521Z","comments":true,"path":"2018/08/27/filename-case/","link":"","permalink":"http://yoursite.com/2018/08/27/filename-case/","excerpt":"","text":"※ 사소주의톰캣의 배포과정에서는 대소문자 구분을 하지않기 때문에 단순히 대소문자만 바꿔서 저장하면 인식을 못하는 경우가 있다.(파일을 못찾음)배포할때 이미 파일이 존재한다고 인지해서 바뀐 파일명에 대한 파일을 처리해주지 않는다.하지만 인식과정에서는 대소문자 구분을 해주기 때문에 당연히 해당 파일이 존재하지 않는다고 처리된다. -&gt; 해결방법: 다른 문자 추가해서 바꿨다가 다시 대소문자 바꾼 파일명으로 2번에 걸친 과정으로 바꿔준다.","categories":[{"name":"Programing","slug":"Programing","permalink":"http://yoursite.com/categories/Programing/"},{"name":"Web","slug":"Programing/Web","permalink":"http://yoursite.com/categories/Programing/Web/"}],"tags":[]},{"title":"Web Project와 서버 연결하기","slug":"web-modules","date":"2018-08-27T14:01:41.000Z","updated":"2018-08-29T14:55:35.755Z","comments":true,"path":"2018/08/27/web-modules/","link":"","permalink":"http://yoursite.com/2018/08/27/web-modules/","excerpt":"","text":"Dynamic Web Project를 서버에서 실행시키기 위해서 서버와 프로젝트를 연결시켜줘야 한다. 방법1. Server 뷰에서 원하는 톰캣 서버를 우클릭하여 ‘Add and Remove’ 을 누른다. 후에 원하는 프로젝트를 ‘Add’ 해준다. (Front라는 이름의 프로젝트이다.) 방법2.Server 뷰에서 원하는 톰캣 서버를 더블클릭한다.노란색 박스로 표시된 ‘Add Web Module…’을 클릭하면 위와 같은 창이 뜬다. * Document Base: 실제 파일이 저장된 경로* Path: 논리적인 URL 에서 인정되는 경로 브라우저에서 Path에 작성해놓은 경로를 치면 Document Base에 작성된 프로젝트 안에서 파일을 찾는다.ex) Path 를 /lala 로 해놓았고 Front라는 프로젝트의 hi.html을 로드하려면,웹 브라우저의 url에 localhost:port번호/lala/hi.html 라고 작성하면 된다. 방법1로 추가시켰을 경우에는 Path가 자동으로 Document Base와 똑같이 설정된다. * Modules 설정 변경했으면, 서버를 재실행 시켜줘야한다.","categories":[{"name":"Programing","slug":"Programing","permalink":"http://yoursite.com/categories/Programing/"},{"name":"Web","slug":"Programing/Web","permalink":"http://yoursite.com/categories/Programing/Web/"}],"tags":[]},{"title":"톰캣 설치 및 적용","slug":"install-tomcat","date":"2018-08-27T12:45:43.000Z","updated":"2018-08-29T13:49:00.787Z","comments":true,"path":"2018/08/27/install-tomcat/","link":"","permalink":"http://yoursite.com/2018/08/27/install-tomcat/","excerpt":"","text":"톰캣 서버를 설치하고 이클립스에 올려 실행하고자 한다.기존에 이클립스를 Standard 버전을 쓰고 있었는데 해당 버전은 웹 프로젝트에 대한 지원이 안되기 때문에 톰캣 설치에 앞서 우선 이클립스 EE 버전을 새로 설치하려고 한다. Eclipse IDE for Java EE Developers 다운로드-&gt; 오른쪽 위에 ! 가 떠 있으면 선택해서 update 진행 (설치 후 installer 종료하면 update 다시 해야 함)-&gt; ! 사라지면 EE 버전 다운로드 진행 나는 SE 버전을 설치한지 몇 달 됐기 때문에 그 사이에 업데이트 사항이 생겨서..이 과정을 해줘야 했다. 이제 톰켓 웹 서버를 다운받아보자. 톰켓 웹 서버 다운로드http://tomcat.apache.org/- 왼쪽 Download 항목에서 Tomcat 9 클릭- 아래쪽 9.0.11 항목에서 Core: &nbsp;&nbsp;&nbsp;&nbsp;64-bit Windows zip 클릭해서 다운 윈도우에 올려서 사용하는게 아니라 이클립스에 올려서 사용할 예정이다.그러므로 톰캣 다운받을 때 ZIP 파일로 받아야한다. (WINDOW INSTALLER 이 아닌) 이제 마지막으로 다운 받은 톰캣을 이클립스에 올려보자. 이클립스에 Server Runtime 추가Window 메뉴- Preferences 항목&nbsp;&nbsp;&nbsp;&nbsp;- Server 항목&nbsp;&nbsp;&nbsp;&nbsp;- Runtime Environments&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- Add… 버튼 클릭&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- Apache Tomcat v9.0 선택&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- Browser 버튼 -&gt; 압축해제한 Tomcat Directory 선택하고 완료 해당 톰캣 폴더가 이클립스 내부 폴더로 복사됨서버가 설치된게 아니라 서버를 만들 수 있는 환경(서버 실행 환경)이 구축된 것이다. 이제 New -&gt; Server -&gt; Tomcat v9.0 Server 을 선택해 완료하면 하나의 서버가 만들어진다!","categories":[{"name":"Programing","slug":"Programing","permalink":"http://yoursite.com/categories/Programing/"},{"name":"Web","slug":"Programing/Web","permalink":"http://yoursite.com/categories/Programing/Web/"}],"tags":[{"name":"Tomcat","slug":"Tomcat","permalink":"http://yoursite.com/tags/Tomcat/"}]},{"title":"Singleton Pattern을 이용한 Ojdbc 활용 예제 _0823","slug":"jdbcEx-singleton-180823","date":"2018-08-23T05:16:56.000Z","updated":"2018-08-29T13:15:46.916Z","comments":true,"path":"2018/08/23/jdbcEx-singleton-180823/","link":"","permalink":"http://yoursite.com/2018/08/23/jdbcEx-singleton-180823/","excerpt":"","text":"이전 포스팅에서 DTO, DAO를 이용하여 Ojdbc를 활용한 DB작업을 했었다. 아래는 이전 포스팅의 UserDaoImpl 클래스 생성자의 한 부분이다. UserDaoImpl.java1234// 드라이버 로드Class.forName(DRIVER);// DB 연결conn = DriverManager.getConnection(URL, USERNAME, PASSWORD); 만약 여러 DAO 클래스를 작성한다면,위의 코드가(DB 연결객체 생성 코드) 계속 중복해서 쓰이기 때문에 DAO 클래스의 개수만큼 DB와의 연결이 수립된다.-&gt; 싱글톤 패턴으로 해결한다 DBConn.java123456789101112131415161718192021222324252627282930313233343536373839package dbutil;import java.sql.Connection;import java.sql.DriverManager;import java.sql.SQLException;public class DBConn &#123; // DB 연결 정보 public static final String DRIVER = \"oracle.jdbc.driver.OracleDriver\"; public static final String URL = \"jdbc:oracle:thin:@localhost:1521:xe\"; public static final String USERNAME = \"scott\"; public static final String PASSWORD = \"tiger\"; // DB 연결객체 private static Connection conn = null; // private 생성자 private DBConn()&#123; &#125; // Connection 객체 반환 = Singleton Pattern public static Connection getConnection() &#123; // DB 연결이 안되어있을 때만 동작 if (conn == null) &#123; try &#123; Class.forName(DRIVER); //드라이버 로드 // DB 연결객체 생성 conn = DriverManager.getConnection(URL, USERNAME, PASSWORD); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; return conn; &#125;&#125; 위 처럼 DB 연결객체를 싱글톤으로 사용할 수 있도록 따로 클래스를 만들어 준다. 이제 아래의 클래스처럼 객체를 싱글톤으로 얻어 사용하면 된다. UserDaoImpl2.java1234567891011public class UserDaoImpl2 implements UserDao&#123; // DB 연결 객체 -&gt; 싱글톤 private static Connection conn = DBConn.getConnection(); // JDBC 객체 private PreparedStatement ps; private ResultSet rs; // ...(생략)...&#125;","categories":[{"name":"Programing","slug":"Programing","permalink":"http://yoursite.com/categories/Programing/"},{"name":"JDBC","slug":"Programing/JDBC","permalink":"http://yoursite.com/categories/Programing/JDBC/"}],"tags":[{"name":"Singleton","slug":"Singleton","permalink":"http://yoursite.com/tags/Singleton/"}]},{"title":"DAO를 이용한 Ojdbc 활용 예제(USER) _0822","slug":"jdbcEx-user-180822","date":"2018-08-23T03:26:42.000Z","updated":"2018-08-29T15:07:24.574Z","comments":true,"path":"2018/08/23/jdbcEx-user-180822/","link":"","permalink":"http://yoursite.com/2018/08/23/jdbcEx-user-180822/","excerpt":"","text":"JDBC를 이용해 USERTEST테이블에 접근하여 몇 가지 쿼리를 수행한다. (UserDao 클래스 참고) 이전 포스팅의 예제에서는 main 함수가 있는 클래스에 DB 연결, SQL 문 수행 등 모든 작업이 한 번에 이루어 졌었다.이번에는 DAO를 이용하여 코드를 작성하였다.메인 함수 실행부와 DB 연결 및 SQL작성부를 분리시킨다. * DAO: 데이터베이스에 수행할 SQL 문을 하나의 메소드의 기능으로 구현하여 모아놓은 객체 [패키지 구성] user ├ dao │ ├ UserDao.java (인터페이스) │ └ UserDaoImpl.java │ ├ dto │ └ User.java └ ex &nbsp;&nbsp;&nbsp;&nbsp;└ UserEx.java UserDao 인터페이스12345678910111213141516171819202122package user.dao;import java.util.List;import user.dto.User;public interface UserDao &#123; //UserTest 테이블 전체 조회 // idx 정렬 public List&lt;User&gt; selectAll(); // idx를 이용한 UserTest 조회 // 1명이 조회되도록 한다 public User selectByIdx(int idx); // User 삽입 public void insertUser(User insertUser); // idx를 이용한 UserTest 삭제 public void deleteByIdx(int idx);&#125; UserDaoImpl.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187package user.dao;import java.sql.Connection;import java.sql.DriverManager;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;import java.util.ArrayList;import java.util.List;import user.dto.User;public class UserDaoImpl implements UserDao&#123; // DB 연결 정보 private final String DRIVER = \"oracle.jdbc.driver.OracleDriver\"; private final String URL = \"jdbc:oracle:thin:@localhost:1521:xe\"; private final String USERNAME = \"scott\"; private final String PASSWORD = \"tiger\"; // DB 연결 객체 private Connection conn; // JDBC 객체 private PreparedStatement ps; private ResultSet rs; public UserDaoImpl() &#123; try &#123; // 드라이버 로드 Class.forName(DRIVER); conn = DriverManager.getConnection(URL, USERNAME, PASSWORD); // 오토커밋 설정(기본값 : true) // 오토커밋 시 중간에 에러나서 프로그램종료되면 자동커밋, 데이터 깨질 수 있음 conn.setAutoCommit(false); // 이러면 commit, rollback 관리를 명시적으로 해줘야함 &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; @Override public List&lt;User&gt; selectAll() &#123; String sql = \"SELECT * FROM userTest ORDER BY idx\"; List&lt;User&gt; userList = new ArrayList&lt;&gt;(); try &#123; ps = conn.prepareStatement(sql); rs = ps.executeQuery(); while(rs.next()) &#123; User user = new User(); user.setIdx(rs.getInt(\"idx\")); user.setUserid(rs.getString(\"userid\")); user.setName(rs.getString(\"name\")); userList.add(user); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; rs.close(); ps.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; return userList; &#125; @Override public User selectByIdx(int idx) &#123; String sql = \"SELECT * FROM userTest WHERE idx = ?\"; User user = null; try &#123; ps = conn.prepareStatement(sql); ps.setInt(1, idx); rs = ps.executeQuery(); user = new User(); if(rs.next()) &#123; user.setIdx(rs.getInt(\"idx\")); user.setName(rs.getString(\"name\")); user.setUserid(rs.getString(\"userid\")); &#125; else &#123; System.out.println(\"** 조회: 해당 IDX에 해당하는 유저가 없습니다.\"); return null; &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; rs.close(); ps.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; return user; &#125; @Override public void insertUser(User insertUser) &#123; String userId = insertUser.getUserid(); String userName = insertUser.getName(); String sql = \"INSERT INTO userTest(idx, userid, name) VALUES (userTest_SQ.nextval,?,?)\"; String sql2 = \"SELECT COUNT(*) FROM userTest WHERE userid = upper(?)\"; try &#123; // 중복 아이디 체크 PreparedStatement ps2 = conn.prepareStatement(sql2); ps2.setString(1, userId); rs = ps2.executeQuery(); rs.next(); // 해당 아이디가 있다면 추가 X if(rs.getInt(1) &gt; 0) &#123; System.out.println(\"** 삽입: 같은 ID 가 존재합니다.\"); &#125; else &#123; // user 추가 ps = conn.prepareStatement(sql); ps.setString(1, userId); ps.setString(2, userName); ps.executeUpdate(); &#125; conn.commit(); // 명시적으로 커밋하기 &#125; catch (SQLException e) &#123; e.printStackTrace(); try &#123; conn.rollback(); // 예외 발생 시 롤백 &#125; catch (SQLException e1) &#123; e1.printStackTrace(); &#125; &#125; finally &#123; try &#123; rs.close(); ps.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; @Override public void deleteByIdx(int idx) &#123; String sql = \"DELETE userTest WHERE idx = ?\"; try &#123; ps = conn.prepareStatement(sql); ps.setInt(1, idx); if( ps.executeUpdate() == 0) &#123; System.out.println(\"** 삭제: 해당 IDX에 해당하는 유저가 없습니다.\"); &#125; conn.commit(); // 명시적으로 커밋하기 &#125; catch (SQLException e) &#123; e.printStackTrace(); try &#123; conn.rollback(); // 예외 발생 시 롤백 &#125; catch (SQLException e1) &#123; e1.printStackTrace(); &#125; &#125; finally &#123; try &#123; ps.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; ** 메소드 안의 catch문에서 자원 해제할 때 conn은 close()하면 안된다. 연결 객체를 해제해버리면 다른 메소드에서 접근 할 수 없다.","categories":[{"name":"Programing","slug":"Programing","permalink":"http://yoursite.com/categories/Programing/"},{"name":"JDBC","slug":"Programing/JDBC","permalink":"http://yoursite.com/categories/Programing/JDBC/"}],"tags":[]},{"title":"코드블럭 스타일 바꾸기","slug":"codeBlockSpace","date":"2018-08-23T01:17:45.000Z","updated":"2018-08-29T15:14:48.897Z","comments":true,"path":"2018/08/23/codeBlockSpace/","link":"","permalink":"http://yoursite.com/2018/08/23/codeBlockSpace/","excerpt":"","text":"코드블럭의 탭 간격 바꾸기_config.yml 파일에서12highlight: tab_replace: &apos; &apos; tab_replace:에 원하는 만큼의 간격을 넣어준다. 간단하게 바꿀 수 있는 거였는데, 별로의 css 파일을 수정하거나 플러그인을 따로 설치하는건가 싶어 엄청 헤맸다.. 코드블럭의 하이라이트 스타일 바꾸기현재 HUEMAN 테마를 사용 중이다. themes\\hueman\\_config.yml 파일을 열어12customize: highlight: highlight: 에 원하는 스타일명을 넣어주면 된다. 바꿔주려는 명은 css\\highlight에 존재하는 파일명중 하나로 바꿔주면 된다.","categories":[],"tags":[]},{"title":"PreparedStatement을 이용한 Ojdbc 사용 예제 _0821","slug":"jdbcEx-180821","date":"2018-08-22T14:23:12.000Z","updated":"2018-08-29T15:05:55.139Z","comments":true,"path":"2018/08/22/jdbcEx-180821/","link":"","permalink":"http://yoursite.com/2018/08/22/jdbcEx-180821/","excerpt":"","text":"DB의 emp 테이블에서 job = ‘SALESMAN’ 인 컬럼들을 조회하여 출력한다.출력 시 Emp 클래스를 이용하여 출력한다. Emp는 DTO클래스로 따로 만들었다. (사용 필드, toString, getter/setter) ※ PreparedStatement 사용 : 더 안전하고 활용도 큼 -&gt; Statement 대신 이걸로 쓰기! 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485package ojdbc;import java.sql.Connection;import java.sql.DriverManager;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;import java.util.ArrayList;import java.util.List;import dto.Emp;public class OjdbcEx_04 &#123; // OJDBC DRIVER private static final String DRIVER = \"oracle.jdbc.driver.OracleDriver\"; // DB 연결 정보 private static final String URL = \"jdbc:oracle:thin:@localhost:1521:xe\"; private static final String USERNAME = \"scott\"; private static final String PASSWORD = \"tiger\"; // OJDBC 객체 private static Connection conn; // DB 연결객체 private static PreparedStatement ps; // SQL 수행객체 private static ResultSet rs; // 조회결과 public static void main(String[] args) &#123; try &#123; // 드라이버 로드 Class.forName(DRIVER); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; // ?없어도 PreparedStatement 사용가능 String sql = \"SELECT * FROM emp WHERE job = ? ORDER BY empno\"; try &#123; conn = DriverManager.getConnection(URL, USERNAME, PASSWORD); ps = conn.prepareStatement(sql); // SQL의 첫번째 ? 에 데이터를 넣는다 ps.setString(1, \"SALESMAN\"); // SQL 쿼리 수행 rs = ps.executeQuery(); // 쿼리 결과를 담은 List List&lt;Emp&gt; list = new ArrayList&lt;&gt;(); // 쿼리 결과 list 에 담기 while(rs.next()) &#123; //데이터가 없으면 false // 매번 emp 객체 생성해서 해당 객체를 list 에 넣는다 Emp emp = new Emp(); emp.setEmpno(rs.getInt(\"empno\")); emp.setEname(rs.getString(\"ename\")); emp.setJob(rs.getString(\"job\")); emp.setMgr(rs.getInt(\"mgr\")); emp.setHiredate(rs.getDate(\"hiredate\")); emp.setSal(rs.getInt(\"sal\")); emp.setComm(rs.getInt(\"comm\")); emp.setDeptno(rs.getInt(\"deptno\")); list.add(emp); &#125; // 쿼리 결과 출력 for( Emp e : list) &#123; System.out.println(e); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; rs.close(); ps.close(); conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; ** 드라이버 로드해주는 코드는 ojdbc4.jar 인가 ojdbc6.jar 부터는 자동으로 해줘서 안써도 실행은 된다고 한다.","categories":[{"name":"Programing","slug":"Programing","permalink":"http://yoursite.com/categories/Programing/"},{"name":"JDBC","slug":"Programing/JDBC","permalink":"http://yoursite.com/categories/Programing/JDBC/"}],"tags":[{"name":"DAO","slug":"DAO","permalink":"http://yoursite.com/tags/DAO/"},{"name":"DTO","slug":"DTO","permalink":"http://yoursite.com/tags/DTO/"},{"name":"PreparedStatement","slug":"PreparedStatement","permalink":"http://yoursite.com/tags/PreparedStatement/"}]},{"title":"DAO & DTO","slug":"DAODTO","date":"2018-08-22T13:26:20.000Z","updated":"2018-08-22T14:38:32.903Z","comments":true,"path":"2018/08/22/DAODTO/","link":"","permalink":"http://yoursite.com/2018/08/22/DAODTO/","excerpt":"","text":"DTO, Data Transmission Object(프레임워크 단에서 주로 쓰이는 용어) 데이터 전송 객체 VO (Value Object) 계층간 데이터 교환을 위한 자바 클래스( Java Beans: , JAVA EE(EnterPrise : 웹이나 대규모 플젝할 때 쓰임, (JAVA SE (기본))) - 이쪽에서 주로 사용하는 용어) DTO 클래스 명은 테이블의 이름과 같게 하는 것이 좋다 멤버 필드는 모두 private(데이터베이스 테이블의 컬럼명과 같게 하는 것이 좋다) 메소드는 getter, setter, toString() 만 작성 ** VO : 데이터로만 이뤄진 객체 &nbsp;&nbsp;&nbsp;&nbsp;DTO : VO 랑 거의 같은 의미. 전송을 목적으로 했을 때 DTO 라고 씀 DAO, Data Access Object Database의 데이터에 접근하기 위한 객체 데이터베이스에 수행할 SQL 문을 하나의 메소드의 기능으로 구현하여 모아놓은 객체","categories":[{"name":"Programing","slug":"Programing","permalink":"http://yoursite.com/categories/Programing/"},{"name":"JDBC","slug":"Programing/JDBC","permalink":"http://yoursite.com/categories/Programing/JDBC/"}],"tags":[{"name":"DAO","slug":"DAO","permalink":"http://yoursite.com/tags/DAO/"},{"name":"DTO","slug":"DTO","permalink":"http://yoursite.com/tags/DTO/"}]}]}