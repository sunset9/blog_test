{"meta":{"title":"Don't forget","subtitle":"lazy","description":null,"author":"Hae Jin","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"파일 업로드 (Commons-fileupload Lib활용)","slug":"fileupload-01","date":"2018-09-28T06:55:38.000Z","updated":"2018-09-28T07:22:04.980Z","comments":true,"path":"2018/09/28/fileupload-01/","link":"","permalink":"http://yoursite.com/2018/09/28/fileupload-01/","excerpt":"","text":"VIEW input 태그의 type을 file로 지정해주면 파일 업로드용 버튼으로 자동 생성된다. enctype 꼭 변경해주기! fileUpload.jsp12345678910111213141516171819202122232425&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!-- 파일 업로드 폼 --&gt;&lt;!-- (기본) enctype=\"application/x-www-form-urlencoded\" --&gt;&lt;!-- (변경) enctype=\"multipart/form-data\" --&gt;&lt;!-- enctype을 바꾸지않으면 파일명만 전달된다. (form-data로 변경하면 파일 내용까지 전달) --&gt;&lt;form action=\"/file/upload\" method=\"post\" enctype=\"multipart/form-data\"&gt;&lt;label&gt;제목: &lt;input type=\"text\" name=\"title\"&gt;&lt;/label&gt;&lt;br&gt;&lt;label&gt;첨부: &lt;input type=\"file\" name=\"uploadFile\"&gt;&lt;/label&gt;&lt;br&gt;&lt;button type=\"submit\"&gt;업로드&lt;/button&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"Programing","slug":"Programing","permalink":"http://yoursite.com/categories/Programing/"},{"name":"Web","slug":"Programing/Web","permalink":"http://yoursite.com/categories/Programing/Web/"}],"tags":[]},{"title":"파일 업로드를 위한 환경 세팅","slug":"fileupload-00","date":"2018-09-28T06:50:56.000Z","updated":"2018-09-28T07:18:13.288Z","comments":true,"path":"2018/09/28/fileupload-00/","link":"","permalink":"http://yoursite.com/2018/09/28/fileupload-00/","excerpt":"","text":"파일 업로드 라이브러리를 활용하는 2가지 방법이 있다. 1. commons-fileupload 라이브러리 + Commons-io 라이브러리(같이 필요) [commons-fileupload 다운방법] apache.org 접속 상단 메뉴 Projects 클릭 Commons 링크 찾아서 클릭 Fileupload 링크 찾아서 클릭 왼쪽 메뉴 Download 클릭 Binaries에서 .zip 다운 압축 해제 commons-fileupload-1.3.3.jar 사용 [Commons-io 다운방법] io 링크 찾아서 클릭 왼쪽 메뉴 Download 클릭 Binaries에서 .zip 다운 압축 해제 commons-io-2.6.jar 사용 2. COS 라이브러리 보통 라이브러리를 다운 받을 때 bin/ src 형식이 있다. src는 실제 java 파일이 들어있고, 프로젝트에 추가하여 컴파일할 수 있고 커스텀마이징이 가능하다.bin 형식 안에는 jar 압축파일로 라이브러리가 제공된다. jar 형식의 라이브러리: java 코드를 모두 컴파일해서 바이트 코드로 변경된 것들이 모여져 있음 = 실행가능한 파일 [라이브러리 사용]jar 파일을 ‘WebContent - WEB-INF - lib’ 폴더 안에 넣어주면자동으로 ‘Java Resorces - Libraries - Web App Libraries’ 폴더안에 추가된다. 만약 자동으로 추가가 안된다면, ‘프로젝트 우클릭 - Build Path - Configure Build Path.. - Libraries탭 - Add External JARs…’ 버튼을 눌러서 직접 추가해준다.","categories":[{"name":"Programing","slug":"Programing","permalink":"http://yoursite.com/categories/Programing/"},{"name":"Web","slug":"Programing/Web","permalink":"http://yoursite.com/categories/Programing/Web/"}],"tags":[]},{"title":"HTTP Protocol","slug":"http-Protocol","date":"2018-09-28T01:29:06.000Z","updated":"2018-09-28T06:56:16.566Z","comments":true,"path":"2018/09/28/http-Protocol/","link":"","permalink":"http://yoursite.com/2018/09/28/http-Protocol/","excerpt":"","text":"1. Request 메시지 // —요청 헤드 요청 라인(스타트 라인)메소드(GET, POST)URLHTTP 버전(HTTP/1.0, HTTP/1.1(우리는 이 버전을 쓴다)) 요청 헤더 : 키-값 쌍으로 들어감Accept : 클라이언트가 받아들일 수 있는 형태Cookie : 쿠키정보Content-Type : 메시지 바디 타입Content-Length : 메시지 바디 타입Connection : 연결정보 // —요청 바디 요청 바디(엔티티 Entity, 페이로드 Payload)요청 파라미터(쿼리스트링) 2. Response 메시지 // —응답 헤드 응답 라인 (스타트 라인)HTTP버전상태코드 : 200, 404, 405, 500, 403상태 메시지 : HTTP/1.1 200 OK, HTTP/1.1 404 Not Found 응답 헤어Content-Type : 바디 내용의 데이터 형식, text/htmlContent-Length : 바디 내용의 길이Set-Cookie : 쿠키 설정 // —응답 바디 응답 바디응답 정보(주로 HTML)","categories":[{"name":"Programing","slug":"Programing","permalink":"http://yoursite.com/categories/Programing/"},{"name":"Web","slug":"Programing/Web","permalink":"http://yoursite.com/categories/Programing/Web/"}],"tags":[]},{"title":"JDBC 사전 준비","slug":"ready-jdbc","date":"2018-09-19T06:46:12.000Z","updated":"2018-09-19T06:49:23.723Z","comments":true,"path":"2018/09/19/ready-jdbc/","link":"","permalink":"http://yoursite.com/2018/09/19/ready-jdbc/","excerpt":"","text":"JDBC를 이용한 프로젝트 개발 시 사전준비 할 것 ojdbc6.jar -&gt; ‘WebContent - WEB-INF - lib’ 폴더로 복사 DBConn.java 파일(DB 객체 싱글톤으로 이용할 수 있게 이전에 만들어 놓은 파일) -&gt; ‘Java Resource - src - dbutil’ 폴더로 복사(DB 객체 생성 파트는 항상 똑같아서 그냥 복붙해서 쓰려고..)","categories":[{"name":"Programing","slug":"Programing","permalink":"http://yoursite.com/categories/Programing/"},{"name":"JDBC","slug":"Programing/JDBC","permalink":"http://yoursite.com/categories/Programing/JDBC/"}],"tags":[]},{"title":"자바빈","slug":"javabean","date":"2018-09-14T07:57:11.000Z","updated":"2018-09-19T07:58:52.760Z","comments":true,"path":"2018/09/14/javabean/","link":"","permalink":"http://yoursite.com/2018/09/14/javabean/","excerpt":"","text":"자바 빈, Java Bean 자바 클래스 프로그램에서 사용할 정보를 모아놓은 데이터 저장소 DTO 로 사용됨 자바빈 설계 원칙(규칙) 로직 X 기능을 담은 메소드를 구현하지 않는다 디폴트 패키지를 사용하지 않는다( 패키지가 반드시 있어야한다) public 클래스로 생성한다 멤버필드는 private으로 지정한다 생성자는 디폴트 생성자만 허용한다(만들지 않는 게 좋다) getter, setter 를 구현한다 getter, setter는 public 접근제한자를 가진다 getter의 반환타입이 boolean이면 get대신 is를 쓸 수 있다 시스템에 등록된 자바빈의 멤버변수는 Property(프로퍼티)라고 부른다 POJO, Plain Old Java Object 어플리케이션의 규모가 커지면서 캡슐화된 클래스의 규모도 너무 커지게 되자 나온 개념 개발자가 마음대로 정의할 수 있는 객체(extends 나 implements를 하지않고 Object만 부모로 가지는 객체) 가볍고, 유연하고, 간단한 객체 그냥 일반 클래스,,,이걸 적용한게 DTO,,,","categories":[{"name":"Programing","slug":"Programing","permalink":"http://yoursite.com/categories/Programing/"},{"name":"Web","slug":"Programing/Web","permalink":"http://yoursite.com/categories/Programing/Web/"}],"tags":[]},{"title":"JSP 내장 객체","slug":"jsp-implict-object","date":"2018-09-13T07:10:45.000Z","updated":"2018-09-19T07:47:52.243Z","comments":true,"path":"2018/09/13/jsp-implict-object/","link":"","permalink":"http://yoursite.com/2018/09/13/jsp-implict-object/","excerpt":"","text":"JSP 내장 객체 JSP페이지에서 객체 생성 없이 바로 사용할 수 있는 객체들 서블릿 컨테이너에 의해 JSP-&gt;Servlet으로 변환될 때 자동 생성됨 내장 객체의 종류 입출력(요청,응답) 관련 객체– request : HTTP요청 객체– response : HTTP응답 객체– out : 응답 객체 출력 스트림 서블릿 관련 객체– page : 서블릿으로 변환된 페이지 객체(서블릿으로 변환된 JSP 자기 자신)– config : 서블릿 설정 정보를 저장하고 있는 객체 정보 전달 객체– pageContext : Page Scope에 들어있는 컨텍스트 정보– request : Request Scope에 들어있는 컨텍스트 정보– session : Session Scope에 들어있는 컨텍스트 정보– application : Application Scope에 들어있는 컨텍스트 정보 예외 처리 관련 객체– exception : page지시자의 isErrorPage속성을 true로 설정하면 사용할 수 있는 객체, 예외정보를 가진다 내장객체의 유효범위(Scope) page : 하나의 JSP페이지를 처리하는 동안 유지 (pageContext 객체를 사용) request : 하나의 요청(HTTP Request)를 처리하는 동안 유지 (MODEL2 환경의 Controller - VIEW 로 이어지는 동안 유지) (ex.Controller - setAttribute -&gt; VIEW: getAttribute 로 이용가능한 이유) session : 연결된 하나의 브라우저에게 서비스하는 동안 유지 (페이지를 이동해도 유지됨) (브라우저끼리는 별개로 유지) application : 동일한 웹어플리케이션이 구동되는 동안 유지 (서버가 켜지고 꺼질 때까지 유지됨) ** 컨텍스트 정보 저장 : setAttribute(“변수명”, 값)** 컨텍스트 정보 읽기 : getAttribute(“변수명”) ex)1234567891011121314151617181920212223// -----------------------------// requestrequest.setAttribute(&quot;name&quot;, name);request.getAttribute(&quot;name&quot;);// -----------------------------// sessionsession.setAttribute(&quot;loginState&quot;, true);if( (boolean)session.getAttribute(&quot;loginState&quot;) )&#123; // 로그인 상태 out.write(&quot;환영합니다&quot;);&#125; else &#123; // 비로그인 상태 out.write(&quot;로그인이 필요합니다&quot;);&#125;// -----------------------------// pagepageContext.setAttribute(&quot;data&quot;, &quot;hi&quot;);// -----------------------------// applicationapplication.setAttribute(&quot;info&quot;, info); *** 위의 내용들은 JSP 문법 내에서 쓰이는 이름이다. 서블릿 내에서 사용할 때는 달라질 수 있다.","categories":[{"name":"Programing","slug":"Programing","permalink":"http://yoursite.com/categories/Programing/"},{"name":"JSP","slug":"Programing/JSP","permalink":"http://yoursite.com/categories/Programing/JSP/"}],"tags":[]},{"title":"MVC예제 - 간단한 회원가입","slug":"servletEx-member","date":"2018-09-12T12:27:38.000Z","updated":"2018-09-19T12:58:08.244Z","comments":true,"path":"2018/09/12/servletEx-member/","link":"","permalink":"http://yoursite.com/2018/09/12/servletEx-member/","excerpt":"","text":"MVC 패턴을 이용한 간단한 회원가입 기능을 구현해보고자 한다. 아래는 프로젝트 구조이다.이번에는 service를 추가해서 구현하였다. (이전 버전은 블로그에 정리해두지 않았다) [구조] Controller: MemberController.java - Servlet Class DAO: MemberDao.java - Interface: MemberDaoImpl.java - Class DBUtil: DBConn.java - Class DTO: Member.java - Class Service: MemberService - Interface: MemberServiceImpl - Class VIEW: joinForm.jsp - JSP: result.jsp - JSP [구현 코드] MemberController.java123456789101112131415161718192021222324252627282930313233343536373839404142434445package controller;import java.io.IOException;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import dto.Member;import service.MemberService;import service.MemberServiceImpl;@WebServlet(\"/member/join\")public class MemberController extends HttpServlet &#123; private static final long serialVersionUID = 1L; private MemberService memberService = new MemberServiceImpl(); @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; // VIEW 지정 req.getRequestDispatcher(\"/view/member/joinForm.jsp\").forward(req, resp); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; // 요청파라미터 한글 처리 인코딩 설정 (UTF-8) req.setCharacterEncoding(\"utf-8\"); // Service를 통한 요청파라미터처리 Member mem = memberService.getMemberParameter(req, resp); // Service를 통한 회원가입(데이터베이스 삽입) boolean joinResult = memberService.join(mem); // join결과 request에 담기 // VIEW에 전달할 MODEL값을 담기 req.setAttribute(\"joinResult\", joinResult); // VIEW 지정하기 req.getRequestDispatcher(\"/view/member/result.jsp\").forward(req, resp); &#125;&#125;","categories":[{"name":"Programing","slug":"Programing","permalink":"http://yoursite.com/categories/Programing/"},{"name":"Web","slug":"Programing/Web","permalink":"http://yoursite.com/categories/Programing/Web/"}],"tags":[]},{"title":"JSP 기본 태그","slug":"jsp-basic-tag","date":"2018-09-12T06:51:51.000Z","updated":"2018-09-28T03:20:51.831Z","comments":true,"path":"2018/09/12/jsp-basic-tag/","link":"","permalink":"http://yoursite.com/2018/09/12/jsp-basic-tag/","excerpt":"","text":"JSP 문법 HTML문서 양식에 Java코드를 삽입하는 형식 Servlet컨테이너(WAS)에 의해 Servlet코드로 변경된다 * Servlet 코드로 변경되어 저장되는 위치: 프로젝트위치\\.metadata\\.plugins\\org.eclipse.wst.server.core \\tmp0\\work\\Catalina\\localhost\\ \\ 프로젝트명\\org\\apache\\jsp JSP 기본 태그 스크립트릿(Scriptlet) &lt;%&nbsp;&nbsp;&nbsp;%&gt; 선언(Declaration) &lt;%!&nbsp;&nbsp;%&gt; 표현식(Expression) &lt;%=&nbsp;&nbsp;%&gt; 지시자(Directive) &lt;%@&nbsp;&nbsp;%&gt; 주석(comment) &lt;%--&nbsp;&nbsp;--%&gt; 스크립트릿(Scriptlet), &lt;%&nbsp;&nbsp;&nbsp;%&gt; JSP에서 자바코드를 작성하기위해 지정하는 영역 수행코드를 위주로 작성한다 (제어문, 메소드호출, 연산 등등) _jspService() 메소드 내에 변환되어 작성된다 선언(Declaration), &lt;%!&nbsp;&nbsp;%&gt; JSP페이지에서 사용할 변수, 메소드를 정의할 때 사용하는 영역 JSP를 변환한 서블릿클래스의 클래스 영역에 정의된다 멤버필드, 멤버메소드로 만들어진다 변수 선언코드, 메소드 정의코드만 작성하도록 한다 표현식(Expression), &lt;%=&nbsp;&nbsp;%&gt; HTML문서에 포함될 내용을 간단히 작성하기 위한 영역 자바데이터를 HTML문서에 간단히 출력할 수 있다 서블릿 컨테이너에 의해 out.print() 코드로 변환된다 ; 을 넣지 않는다 지시자(Directive), &lt;%@&nbsp;&nbsp;%&gt; Servlet/JSP컨테이너에 메시지를 보내기위한 영역 JSP가 실행될 때 지시자의 내용을 읽어서 JSP페이지 설정에사용할 수 있도록 설정내용을 추가하는 태그 페이지의 특수 정보나 설정들을 처리 JSP-&gt;Servlet으로 변환할 때 필요한 정보를 기술한다 브라우저에서 확인되지 않는다 주석(Comment), &lt;%--&nbsp;&nbsp;--%&gt; HTML 주석&nbsp;&nbsp; &lt;!-- HTML주석 --&gt;웹브라우저가 해석하지 못하게 만든다 JS 주석 &nbsp;&nbsp; /*&nbsp; JS주석&nbsp; */ &nbsp;또는&nbsp; //JS주석&lt;script> 태그 내에서 사용브라우저의 JS엔진이 해석하지 못하게 만든다 CSS 주석 &nbsp;&nbsp; / CSS주석 \\/&lt;style> 태그 내에서 사용브라우저의 CSS엔진이 해석하지 못하게 만든다 JSP 주석 &lt;%-- JSP주석 --%&gt;서블릿 코드로 변환되지 않도록 막는다웹브라우저에 전송되지 않음 Java 주석 /* Java주석 */ &nbsp;또는&nbsp; //Java주석스크립트릿 태그 내에서 사용서블릿컨테이너가 코드를 수행하지 못하게 막는다웹브라우저에 전송되지 않음","categories":[{"name":"Programing","slug":"Programing","permalink":"http://yoursite.com/categories/Programing/"},{"name":"JSP","slug":"Programing/JSP","permalink":"http://yoursite.com/categories/Programing/JSP/"}],"tags":[]},{"title":"서블릿, Servlet","slug":"servlet","date":"2018-09-10T06:46:45.000Z","updated":"2018-09-19T07:53:27.344Z","comments":true,"path":"2018/09/10/servlet/","link":"","permalink":"http://yoursite.com/2018/09/10/servlet/","excerpt":"","text":"서블릿, Servlet Servlet = Server + Applet 서버에서 동작하는 Applet이라는 뜻 Applet : 자바에서 바이트 코드의 형태로 배포되는 실행가능 프로그램 웹 어플리케이션을 작성하는 기술 자바 일반클래스에 HttpServlet 클래스를 상속하면 서블릿 클래스라고 부른다(완성된 Applet파일을 업로드하면 톰캣이 실행시켜 준다 (시점: 브라우저에 접속한 순간)) -&gt; 줄여서 ‘서블릿’이라고 부른다 (javax.servlet.HttpServlet Class) 서블릿 클래스 형태1234import javax.servlet.http.HttpServlet;public class [서블릿클래스명] extends HttpServlet &#123; //클라이언트 요청 처리 코드 (doGet, doPost)&#125; 접근 제한자가 반드시 public doGet, doPost 메소드는 오버라이딩해서 작성한다 서블릿의 동작 원리클라이언트 요청 → (Apache 웹서버 - Tomcat WAS(JVM) ) → 서블릿 컨테이너 → 서블릿객체 → service() (멀티스레딩) → doGet() / doPost()→ 서블릿 컨네이너 → Apache- Tomcat 웹서버 → 클라이언트 응답 ** 요청되는 정보 : url + 메소드(get/post) + 요청파라미터(쿼리스트링 (url 뒤에 ?로 붙는 값들))** Tomcat에 있는 JVM이 서블릿객체를 컴파일(해석)해준다** WAS 가 서블릿 컨테이너에 어떤 요청이 왔는지 url 등 정보를 판단해서 서블릿 객체로 넘겨줌** 서블릿객체의 service() 가 요청된 정보를 받아서 get/post 를 판별하여 해당하는 메소드를 호출** service() 부터는 멀티스레딩 방식으로 각 각의 요청을 따로 처리해준다 ** /image.jpg 같은 것을 url 로 요청했을 때는 WAS-서블릿 컨테이너를 거치지 않고 Apache 웹서버가 바로 해당 파일을 읽어와준다. ** 서블릿 컨테이너 서블릿 처리환경을 구축하는 역할 서블릿을 실행시켜주는 역할 WAS 서버와 서블릿객체 사이의 중간다리 역할을 수행한다 요청 URL-Pattern 과 서블릿객체를 1:1 매핑해놓고 요청을 기다린다 (WAS 안에 들어있다.) (WAS 가 web.xml 을 보고 만들어 놓는다) 서블릿 객체 라이프 사이클(생명주기)객체 생성 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ init()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ service()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→destroy()(생성자호출) (서블릿초기화) (doGet(),doPost() 반복수행) : init() 까지 수행하고 기다리고 있다가 클라이언트에게 요청이 들어오면 service() (멀티스레딩 형식으로) 가 수행된다.모든 서블릿 객체가 위와 같은 사이클로 실행된다.** 웹서비스를 처음 실행하고 첫 클라이언트는 조금 느려진다. (서블릿마다 init() 작업까지 수행해줘야하기 때문에)","categories":[{"name":"Programing","slug":"Programing","permalink":"http://yoursite.com/categories/Programing/"},{"name":"JSP","slug":"Programing/JSP","permalink":"http://yoursite.com/categories/Programing/JSP/"}],"tags":[]},{"title":"프로그래밍 아키텍쳐/ MODEL 1,2 / MVC Pattern","slug":"programing-architecture","date":"2018-09-10T06:34:52.000Z","updated":"2018-09-19T07:52:42.594Z","comments":true,"path":"2018/09/10/programing-architecture/","link":"","permalink":"http://yoursite.com/2018/09/10/programing-architecture/","excerpt":"","text":"프로그래밍 아키텍쳐 프로그램 작성 구조(구성) MODEL 1 : 비지니스 로직과 프레젠테이션 로직을 합쳐놓은 것 MODEL 2 : 비지니스 로직과 프레젠테이션 로직을 분리시켜 놓은 것 비지니스 로직, Business Logic 클라이언트(사용자)에게 보이지 않는 부분 데이터를 처리하는 (가공하는) 응용프로그램의 일부 영역 주로 데이터베이스 처리 ex) 로그인 데이터 인증(데이터베이스 존재 여부 확인) Servlet으로 구현함 Server Side Script (Language) : Java(Servlet) 프레젠테이션 로직, Presentation Logic 클라이언트에게 보여지는 부분 표현될 화면을 구성하기 위한 응용프로그램의 일부 영역 JSP 로 구현 Client Side Script(Language) : HTML, CSS, JS MODEL 1,2 / MVC PatternMODEL 1 비지니스 로직 + 프레젠테이션 로직을 하나의 파일로 구현한 것 장점 – 작업(개발)이 쉽다 – 구조가 단순해서 직관적이다 – 중소형 프로젝트에 어울림 단점 – 코드가 섞여있어서 유지보수가 어렵다 – 프로젝트 적응력이 떨어진다 – 재사용성이 떨어진다 – 분업이 힘들다 – 대형 프로젝트에 어울리지 않는다 MODEL 2 비지니스 로직과 프레젠테이션 로직을 다른 파일로 분리한 형태 대형 프로젝트에 잘 어울리며 분업하기에 적절하다 단, MODEL 2 개발방식에 대한 이해가 필요하며 기본 지식의 요구수준이 높다 MVC 패턴 MODEL : 데이터, JavaBean Class (DTO Class) VIEW : 프레젠테이션 로직, JSP (HTML) CONTROLLER : 비지니스 로직, Servlet (요청파라미터처리, DAO) * DAO : DB접근 객체( 데이터베이스의 자료를 관리하는 객체)&nbsp;&nbsp;&nbsp;DTO : 모델이 되는 객체&nbsp;&nbsp;&nbsp;(** 테이블 하나 당 DAO 클래스 하나로 만들면 좋음)","categories":[{"name":"Programing","slug":"Programing","permalink":"http://yoursite.com/categories/Programing/"},{"name":"Web","slug":"Programing/Web","permalink":"http://yoursite.com/categories/Programing/Web/"}],"tags":[]},{"title":"jQuery 사용하기","slug":"jQuery-use","date":"2018-09-06T04:01:02.000Z","updated":"2018-09-19T07:12:01.647Z","comments":true,"path":"2018/09/06/jQuery-use/","link":"","permalink":"http://yoursite.com/2018/09/06/jQuery-use/","excerpt":"","text":"jQuery Core jQuery $ jQuery 문법이 적용되었음을 알리는 키워드 1234567 jQuery(document).ready(function() &#123; &#125;);//---------------------------------------- $(document).ready(function() &#123; &#125;); jQuery Core를 변수에 저장하여 사용할 수도 있다12345var J = jQuery;J(document).ready(function() &#123; J(&quot;div&quot;).css(&quot;color&quot;, &quot;blue&quot;);&#125;); jQuery 노드 객체 찾기 $(셀렉터) $(js객체) jQuery DOM객체로 노드를 반환한다 n번째 노드 접근하기 $(객체).eq(idx) : idx번째 노드를 jQuery DOM객체로 반환 $(객체).get(idx) : idx번째 노드를 JS DOM객체로 반환 123$(&quot;p&quot;).eq(2).css(&quot;color&quot;, &quot;red&quot;);//--------------------------------$(&quot;p&quot;).get(3).style.color = &quot;blue&quot;; 순차적으로 노드 접근하기 $(객체).each( function( idx, element ) {&nbsp;&nbsp;&nbsp;&nbsp;// 요소마다 각각 반복될 코드});idx : 객체의 인덱스element : 해당 반복의 JS 객체 ** 코드 내에서 this 키워드를 사용하면 반복되고있는 노드를 JS객체로 사용가능하다 ( == element 매개변수 ) ** jQuery 객체로 사용하고 싶다면 $(this) 를 사용한다 객체 비교하기 $(객체1).is( $(객체2) )객체1과 객체2가 같은 객체인지 비교 true - 같은 객체false - 다른 객체 하위노드중에서 특정 노드 찾기 $(객체).find( selector )객체의 하위 노드중에서 selector에 맞는 객체 반환 자식 노드 찾기 $(객체).children() $(객체).children( selector ) 부모 노드 찾기 $(객체).parent() $(객체).parent( selector ) 조상 노드 찾기 $(객체).parents() $(객체).parents( selector ) 이전 형제노드 찾기 $(객체).prev() $(객체).prev( selector ) 이전 모든 형제노드 찾기 $(객체).prevAll() $(객체).prevAll( selector ) 다음 형제노드 찾기 $(객체).next() $(객체).next( selector ) 다음 모든 형제노드 찾기 $(객체).nextAll() $(객체).nextAll( selector ) 노드 생성 $(“노드텍스트”)ex) $(“&lt;div>“) -&gt; &lt;div> 태그 생성 ** 주의&nbsp;&nbsp;&nbsp; $(“div”) - div태그 선택&nbsp;&nbsp;&nbsp; $(“&lt;div>“) - div태그 생성 $(객체).html(“노드텍스트”)ex) $(“div”).html(“&lt;p>안녕&lt;/p>“); 노드 복사 $(객체).clone() ex) var $div2 = $(“#myDiv”).clone(); 노드 추가/이동 $부모노드.append( $추가노드 ) $추가노드.appendTo( $부모노드 ) 부모노드의 마지막 자식으로 추가노드 삽입 추가되는 노드가 이미 DOM트리 구성요소면 이동처리됨 $부모노드.prepend( $추가노드 )$추가노드.preondTo( $부모노드 ): 부모노드의 첫 자식으로 추가노드 삽입/이동 $기준노드.before( $추가노드 )$추가노드.insertBefore( $기준노드 ): 기준노드의 이전형제로 추가노드를 삽입/이동 $기준노드.after( $추가노드 )$추가노드.insertAfter( $기준노드 ): 기준노드의 다음형제로 추가노드를 삽입/이동 노드 내용 읽기/변경 $객체.html() $객체.html(“태그를포함한텍스트”) $객체.text() $객체.text(“기본텍스트”)** 매개변수가 없는 함수는 읽기, 매개변수가 있는 함수는 변경하기** html함수는 태그형식을 유지하며 처리** text함수는 태그를 무시하고 단순텍스트로 처리 클래스 속성 다루기(추가/삭제) $(객체).addClass(“클래스명”) $(객체).removeClass(“클래스명”) $(객체).removeClass() // 전체 클래스 삭제 모든 속성 다루기 $(객체).attr(“속성이름”) : 속성값 가져오기 $(객체).attr(“속성이름”, “속성값”) : 속성값 지정하기 $(객체).attr({“속성명1” : “속성값1”, “속성명2” : “속성값2”,…}); : 여러 속성 지정하기 ** 여러 속성값을 불러오는 방법은 지원되지 않는다","categories":[{"name":"Programing","slug":"Programing","permalink":"http://yoursite.com/categories/Programing/"},{"name":"jQuery","slug":"Programing/jQuery","permalink":"http://yoursite.com/categories/Programing/jQuery/"}],"tags":[]},{"title":"jQuery","slug":"jQuery","date":"2018-09-06T03:58:55.000Z","updated":"2018-09-18T04:00:12.225Z","comments":true,"path":"2018/09/06/jQuery/","link":"","permalink":"http://yoursite.com/2018/09/06/jQuery/","excerpt":"","text":"jQuery? 자바스크립트의 DOM을 쉽게 사용하기위해 만들어진 라이브러리 순수 자바스크립트 코드보다 효율적이고, 코드생산성이 향상됨 HTML노드, 스타일, 속성, 이벤트 등을 다룰 수 있다 CSS 선택자를 이용한다 http://www.jquery.com/ jQuery 주요 기능 jQuery DOM : JS DOM객체를 다루는 기능 jQuery Event : JS Event를 다루는 기능 jQuery Ajax : 비동기통신(Ajax)를 다루는 기능 jQuery Effects : 효과(애니메이션, 모션 등) jQuery Plugin : 추가 기능(플러그인) jQuery 버전별 특징 1.x다양한 브라우저에 호환되는 버전최대한 많은 브라우저에 호환되는 게 목적브라우저 특징에 맞는 동작이 생략된 경우가 있음 2.x코드의 성능, 다양한 기능을 제공하기 위해 IE8이하는 지원X옛 코드를 버리고 경량화하고 성능을 개선함기능도 추가됨 3.x2.x의 업그레이드 버전jQuery Migrate는 1.x 업그레이드 버전","categories":[{"name":"Programing","slug":"Programing","permalink":"http://yoursite.com/categories/Programing/"},{"name":"jQuery","slug":"Programing/jQuery","permalink":"http://yoursite.com/categories/Programing/jQuery/"}],"tags":[]},{"title":"jQuery, CND를 이용해 파일 불러오기","slug":"cnd","date":"2018-09-06T03:53:38.000Z","updated":"2018-09-18T03:57:57.366Z","comments":true,"path":"2018/09/06/cnd/","link":"","permalink":"http://yoursite.com/2018/09/06/cnd/","excerpt":"","text":"CDN, Content Delivery Network jQuery 2.2.4 CDN 12&lt;script src=&quot;https://code.jquery.com/jquery-2.2.4.min.js&quot;&gt;&lt;/script&gt; jQuery를 사용하기 위해 HTML 소스코드에 위와 같은 태그를 삽입해주면 별로의 다운로드 없이 파일을 받아 사용할 수 있다. 콘텐츠(자료)를 효율적으로 전달하기 위해 준비된 네트워크 주로 10MB이상의 파일을 다루지만 요즘엔 크기에 상관없이 사용 클라이어트의 컨텐츠 요청 병목현상을 해결한다 서버의 불필요한 트래픽을 줄이고 반복작업을 줄여준다 자주 사용되는 컨텐츠(자료, 파일)을 네트워크 중간중간에 복사해두고 클라이언트 요청을 받으면 적절한 위치의 컨텐츠를 전송해준다","categories":[{"name":"Programing","slug":"Programing","permalink":"http://yoursite.com/categories/Programing/"},{"name":"jQuery","slug":"Programing/jQuery","permalink":"http://yoursite.com/categories/Programing/jQuery/"}],"tags":[]},{"title":"JS Event Listener 등록하는 방법","slug":"js-eventListener","date":"2018-09-05T11:44:39.000Z","updated":"2018-09-18T03:50:29.008Z","comments":true,"path":"2018/09/05/js-eventListener/","link":"","permalink":"http://yoursite.com/2018/09/05/js-eventListener/","excerpt":"","text":"JS Event Listener 등록하는(바인딩) 방법 1. HTML 태그의 인라인 방식1&lt;div onclick=&quot;alert(&apos;hi!&apos;)&quot;\\&gt;Hello&lt;/div\\&gt; 2. DOM을 이용한 바인딩 - Event Attribute사용1234var e = document.getElementById(&quot;btn&quot;);e.onclick = function()&#123; alert(&quot;HI&quot;);&#125;; 3. DOM을 이용한 바인딩 - addEventListener() 함수 사용1234var e = document.getElementById(&quot;btn&quot;);e.addEventListener(&quot;click&quot;, function()&#123; alert(&quot;Hello&quot;);&#125;); ※ JS 주요 이벤트 속성 onchange 요소가 변경될 때 onsubmit 폼이 제출될 때onreset 폼이 재설정될 때 onselect 값이 선택되었을 때 onfocus 포커스가 얻었을 때onblur 포커스를 잃었을 때 onkeydown 키를 눌렀을 때onkeypress 키를 눌렀다가 놓았을 때onkeyup 키를 놓았을 때 onclick 마우스를 클릭했을 때ondblclick 마우스를 더블클릭했을 때 onmousedown 마우스 버튼을 누르고 있을 때onmouseup 마우스를 놓았을 때 onmousemove 마우스 포인트를 이동했을 때 onmouseout 마우스 포인트가 요소의 바깥으로 이동했을 때onmouseover 마우스 포인트가 요소로 들어왔을 때","categories":[{"name":"Programing","slug":"Programing","permalink":"http://yoursite.com/categories/Programing/"},{"name":"Javascript","slug":"Programing/Javascript","permalink":"http://yoursite.com/categories/Programing/Javascript/"}],"tags":[]},{"title":"DOM 객체 함수 API","slug":"dom-api","date":"2018-09-05T08:23:04.000Z","updated":"2018-09-18T03:43:37.090Z","comments":true,"path":"2018/09/05/dom-api/","link":"","permalink":"http://yoursite.com/2018/09/05/dom-api/","excerpt":"","text":"Element 생성 document.createElement(“tagName”): 요소 노드 만들기 document.createTextNode(“text”): 텍스트 노드 만들기 Element 추가 객체.appendChild(대상) : 객체에 노드 연결(추가)하기 ex) var pTag = document.createElement(“p”);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;document.body.appendChild(pTag); ** document.body: HTML문서의 &lt;body&gt;요소를 객체로 표현한 예약어 Element 속성 지정 객체.표준속성 = 속성값; 객체.setAttribute(속성명, 속성값); ( 표준속성이 아니어도 가능 )12img.width = &quot;300&quot;; // 300px로 넣으면 안됨, px기본으로정해져있음img.setAttribute(&quot;height&quot;, &quot;150&quot;); Element 속성 얻기 객체.표준속성; 객체.getAttribute(속성명); innerHTML (property) 객체.innerHTML = “HTML 양식 문장” : 객체의 자식요소로 HTML 문장이 추가됨1234document.body.innerHTML += &quot;&lt;div&gt;&lt;h1&gt;INNER HTML&lt;/h1&gt;&lt;/div&gt;&quot;// innerHTML 에// = 연산자를 사용하면 기존의 HTML코드를 지워버림// += 연산자를 사용하면 기존코드에 추가한다 Element 객체 얻기 document.getElementById(아이디); document.getElementsByName(name속성값); document.getElementsByTagName(태그);1234567var content = document.getElementById(&quot;content&quot;);content.innerHTML += &quot;&lt;h3&gt;innerHTML&lt;/h3&gt;&quot; + &quot;&lt;p&gt;테스트&lt;/p&gt;&quot; + &quot;&lt;hr&gt;&quot;;//----------------------------------------var h3 = document.getElementsByTagName(&quot;h3&quot;);h3[1].innerHTML = &quot;HI&quot;;h3[2].innerHTML = &quot;Hello&quot;; Element 객체 제거 객체.remove() : 해당 객체 제거 객체.removeChild(node) : 객체의 자식노드 node를 제거","categories":[{"name":"Programing","slug":"Programing","permalink":"http://yoursite.com/categories/Programing/"},{"name":"Javascript","slug":"Programing/Javascript","permalink":"http://yoursite.com/categories/Programing/Javascript/"}],"tags":[]},{"title":"DOM 정리","slug":"dom","date":"2018-09-05T08:06:32.000Z","updated":"2018-09-13T08:18:16.303Z","comments":true,"path":"2018/09/05/dom/","link":"","permalink":"http://yoursite.com/2018/09/05/dom/","excerpt":"","text":"DOM, Document Object Model– 문서 객체 모델– document 내장객체를 뜻한다– HTML 문서의 태그– &lt;body&gt; 태그 내 요소들의 계층구조 == DOM– HTML문서의 요소(태그)들을 자바스크립트 코드로 접근하고 관리하기 위한 인터페이스 관련 용어 요소(Element) : HTML문서 내의 태그 문서 객체(Document Object) : 자바스크립트로 요소에 접근할 수 있도록 객체화 한 것 HTML요소와 자바스크립트의 연결 지점(인터페이스) DOM 트리 : 문서 객체를 트리구조(계층구조)로 표현한 것 노드, Node : DOM 트리 구성 요소 &nbsp;– 요소 노드: 태그 요소 &nbsp;– 텍스트 노드: 태그 요소가 감싸고 있는 텍스트 ex) &lt;h1> Hello &lt;/h1>&nbsp;&nbsp;&nbsp;&nbsp; : &lt;h1> - 요소 노드, “Hello” - 텍스트 노드 DOM 객체를 사용하는 코드의 적용 위치 &lt;head>태그 내 &lt;script>태그에서 window.onload 의 리스너로 작성 12345&lt;script&gt;window.onload = function()&#123; document.getElementById(&quot;id&quot;);&#125;;&lt;/script&gt; &lt;/body> 닫는 태그 바로 위에 &lt;script>태그에서 작성 (window.onload 필요 없음) 일반 함수에서 사용하고 해당 함수를 태그의 이벤트 리스너로 작성 ** DOM객체는 &lt;body>의 계층구조를 모두 확인하고 DOM트리가 완성된 이후에 사용해야 한다.** DOM트리가 완료되는 시점까지 DOM객체를 사용하는 코드가 실행되는 것을 미뤄야 한다.","categories":[{"name":"Programing","slug":"Programing","permalink":"http://yoursite.com/categories/Programing/"},{"name":"Javascript","slug":"Programing/Javascript","permalink":"http://yoursite.com/categories/Programing/Javascript/"}],"tags":[]},{"title":"자바스크립트 핵심 요소 4가지","slug":"js-element","date":"2018-09-03T07:57:14.000Z","updated":"2018-09-13T08:05:37.217Z","comments":true,"path":"2018/09/03/js-element/","link":"","permalink":"http://yoursite.com/2018/09/03/js-element/","excerpt":"","text":"자바스크립트 핵심 요소 4가지 자바스크립트 Core 문법 기본 문법 데이터 타입, 변수, 제어문, 함수, … 클래스, 객체, … 내장 객체(Core Library)(built-in) String, Date, Math, Array, Number, Object, … BOM, Browser Object Model, 브라우저 객체 모델 웹 브라우저 창(윈도우)과 자바스크립트가 통신하기 위한 수단으로 제공되는 객체들 – window객체 브라우저 전반적인 기능 제어 자바스크립트에서 정의한 모든 전역 변수, 함수, 객체들은 window객체의 멤버로 추가된다 ( 전역 변수 var num; -&gt; window.num = 1; 으로 사용 : window는 생략 가능해서 그냥 num = 1; 으로 사용하는 것) Javacript 최상위 객체 – navigator객체 브라우저의 정보와 운영체제의 정보를 제공하는 객체 – location객체 URL과 관련된 인터넷 주소 정보 관련 객체 – history객체 사용자 방문기록 관련 객체 – document객체 웹페이지 문서 관련 객체 –screen객체 사용자 모니터 정보 관련 객체 DOM, Document Object Model, 문서 객체 모델 (별도 정리) Event (별도 정리)","categories":[{"name":"Programing","slug":"Programing","permalink":"http://yoursite.com/categories/Programing/"},{"name":"Javascript","slug":"Programing/Javascript","permalink":"http://yoursite.com/categories/Programing/Javascript/"}],"tags":[]},{"title":"JS 데이터타입","slug":"js-datatype","date":"2018-09-02T07:43:18.000Z","updated":"2018-09-13T07:53:50.250Z","comments":true,"path":"2018/09/02/js-datatype/","link":"","permalink":"http://yoursite.com/2018/09/02/js-datatype/","excerpt":"","text":"JS 데이터타입 Number : 숫자 &nbsp;보라색 String : 문자 &nbsp;검은색 Boolean : 논리 &nbsp;파란색 Object : 객체 &nbsp;{객체} Null : null값 (참조대상 없음) undefined : 정의되지않음 Array : 배열 &nbsp;[배열요소] - NaN, Not a Number&nbsp;&nbsp;: Number타입으로 사용하려는 시점에 Number타입이 아닐 경우 리턴하는 키워드&nbsp;&nbsp;* Booolean isNaN() - NaN인지 검사하는 JS 내장 함수 - Infinity, -Infinity &nbsp;&nbsp;: 양의 무한대, 음의 무한대를 나타내는 키워드 &nbsp;&nbsp;* Boolean isFinite() - Number가 유한한 값인지 검사 - undefined &nbsp;&nbsp;: 변수가 초기화되지 않은 상태의 값 &nbsp;&nbsp;&nbsp;&nbsp;값이 할당되지 않은 상태 &nbsp;&nbsp;&nbsp;&nbsp;데이터타입조차 결정되지 않은 상태 - null&nbsp;&nbsp; : 값이 없음&nbsp;&nbsp;&nbsp;&nbsp;참조값이 없음&nbsp;&nbsp;&nbsp;&nbsp;의도적으로 값을 비워둔 상태&nbsp;&nbsp;&nbsp;&nbsp;Object 타입의 값으로 처리된다","categories":[{"name":"Programing","slug":"Programing","permalink":"http://yoursite.com/categories/Programing/"},{"name":"Javascript","slug":"Programing/Javascript","permalink":"http://yoursite.com/categories/Programing/Javascript/"}],"tags":[]},{"title":"선택자, Selector","slug":"selector","date":"2018-08-30T06:29:01.000Z","updated":"2018-09-13T07:34:51.431Z","comments":true,"path":"2018/08/30/selector/","link":"","permalink":"http://yoursite.com/2018/08/30/selector/","excerpt":"","text":"[선택자, Selector] HTML 문서에서 특정 요소를 선택하는 CSS의 문법 선택된 요소에 일괄적으로 스타일을 적용할 수 있다 [선택자 종류] 전체 선택자 : 모든 요소 \\* { }` 태그 선택자 tagName{ } 아이디 선택자 #idName{ } 클래스 선택자 .className{ } 복합 선택자 두 개 이상의 요소가 모인 선택자 요소들의 관계(계층구조)를 따져 선택한다 1.&nbsp;하위(자손) 선택자(descendant): 아래에 있는 모든 요소들E F : E의 하위 요소인 F를 선택 ex) p .blue { } &nbsp;&nbsp;/* p 태그의 자손요소 중 class가 blue인 요소들*/ (* p.blue { } &nbsp;&nbsp;/* (p와 .사이에 띄어쓰기가 없는 경우) p요소 중 class가 blue인 요소들 */ )2.&nbsp;자식 선택자(child): 바로 아래에 있는 요소 E &gt; F : E의 자식 요소 F 선택 3.&nbsp;형제 선택자(sibling) E + F : E의 인접형제 F ( E요소 바로 뒤에오는 F 요소)E ~ F : E의 일반형제 F ( E요소 뒤따르는 모든 F요소) 속성 선택자 요소의 속성(Attribute)을 이용하여 선택한다 E[attr] : attr속성을 가지고 있는 E태그 E[attr=”val”] : attr속성의 값이 val과 같은 E태그 (ex. h1[class=”abc”] ) E[attr~=”val”] : val을 완전포함하는 E태그 E[attr^=”val”] : val로 시작하는 E태그 E[attr$=”val”] : val로 끝나는 E태그 E[attr*=”val”] : val을 부분포함하는 E태그 E[attr|=”val”] : “val”과 같거나 “val-“로 시작하는 E태그 가상 선택자, pseudo selector, 의사 선택자 HTML 문서에는 실제로 존재하지 않는 요소를 선택 이벤트 기반으로 선택하거나 특정 순서에 의해 선택한다 1.&nbsp;가상 클래스 선택자 (이벤트 기반 선택자)&nbsp;&nbsp;&nbsp;E:hover - onenter, onleave 이벤트(마우스 이벤트)에 반응 &nbsp;&nbsp;&nbsp;E:active - onclick에 반응 &nbsp;&nbsp;&nbsp;E:link - &lt;a>의 방문 전 상태 &nbsp;&nbsp;&nbsp;E:visited - &lt;a>의 방문 후 상태 &nbsp;&nbsp;&nbsp;E:enabled - enable 상태인 요소 &nbsp;&nbsp;&nbsp;E:disabled - disable 상태인 요소 ex) 버튼 비활성화 상태 &nbsp;&nbsp;&nbsp;E:checked - 체크 상태인 요소 &nbsp;&nbsp;&nbsp;E:empty - 비어있는 요소 &nbsp;&nbsp;&nbsp;E:focus - 포커스 가지고 있는 요소 2.&nbsp;가상 요소 선택자&nbsp;&nbsp;&nbsp;::before - 대상요소의 앞 &nbsp;&nbsp;&nbsp;::after - 대상요소의 뒤 &nbsp;&nbsp;&nbsp;::first-line - 요소의 첫 줄 &nbsp;&nbsp;&nbsp;::first-letter - 요소의 첫 글자 3.&nbsp;요소 순서 선택자(가상 클래스에 포함됨) &nbsp;&nbsp;&nbsp;:root - 문서의 최상위 요소 ( &lt;html> ) &nbsp;&nbsp;&nbsp;:nth-child(n) - 앞에서 n번째 요소 &nbsp;&nbsp;&nbsp;:nth-last-child(n) - 뒤에서 n번째 요소 &nbsp;&nbsp;&nbsp;:first-child - 첫 요소 &nbsp;&nbsp;&nbsp;:last-child - 마지막 요소 &nbsp;&nbsp;&nbsp;:only-child - 유일한 자식 (형제요소가 없을 때) &nbsp;&nbsp;&nbsp;:only-of-type - 유일한 타입 (형제요소가 있어도) 부정 선택자 E:not(S) - S조건을 만족하지 않는 E요소 ( S는 Selector )","categories":[{"name":"Programing","slug":"Programing","permalink":"http://yoursite.com/categories/Programing/"},{"name":"CSS","slug":"Programing/CSS","permalink":"http://yoursite.com/categories/Programing/CSS/"}],"tags":[]},{"title":"id, class 속성","slug":"id-class","date":"2018-08-29T07:29:56.000Z","updated":"2018-09-13T07:38:13.110Z","comments":true,"path":"2018/08/29/id-class/","link":"","permalink":"http://yoursite.com/2018/08/29/id-class/","excerpt":"","text":"####id, class 속성 id 속성 ( id=”idName”, #idName )HTML 문서에서 각 요소들을 구분하기 위한 목적으로 사용하는 속성값주로 해당 요소에 기능(이벤트)을 부여할 때 사용한다 class 속성 ( class=”className1 className2”, .className )HTML 문서에서 공통적인 기능(스타일)을 수행해야하는 요소들을 그룹화하여 관리할 때 사용하는 속성 -&gt; 같은 스타일을 여러 요소에 적용-&gt; 같은 이벤트를 여러 요소에 적용 여러 개의 클래스값을 띄어쓰기로 구분해서 부여할 수 있다 ** ID는 웹 브라우저가 참조값을 저장해놔서 적용 속도가 빠르다.CLASS 는 따로 저장해놓지 않아서 문서를 다시 처음부터 읽으면서 CLASS요소들을 찾고 적용해준다.그래서 CLASS가 너무 많거나 구조가 복잡해지면 속도가 느려진다.","categories":[{"name":"Programing","slug":"Programing","permalink":"http://yoursite.com/categories/Programing/"},{"name":"CSS","slug":"Programing/CSS","permalink":"http://yoursite.com/categories/Programing/CSS/"}],"tags":[]},{"title":"이클립스 한글 인코딩(UTF-8) 환경 설정","slug":"setting-encode","date":"2018-08-27T14:58:04.000Z","updated":"2018-08-29T15:04:27.249Z","comments":true,"path":"2018/08/27/setting-encode/","link":"","permalink":"http://yoursite.com/2018/08/27/setting-encode/","excerpt":"","text":"웹에서는 EUC-KR 이나 UTF-8을 많이 사용한다. Window - Preferences 선택 후 General 항목- Workspace 항목- 하단의 Text file encoding의&nbsp;&nbsp;&nbsp;&nbsp;Other: UTF-8 설정 Web 항목- CSS Files- HTML Files- JSP FIles세가지 항목 모두 ISO 10646/Unicode(UTF-8) 로 설정 위와같이 1,2 설정을 해준다.","categories":[{"name":"Programing","slug":"Programing","permalink":"http://yoursite.com/categories/Programing/"}],"tags":[]},{"title":"HTML 파일명의 대소문자만 바꾸는 경우","slug":"filename-case","date":"2018-08-27T14:52:40.000Z","updated":"2018-08-29T14:56:23.521Z","comments":true,"path":"2018/08/27/filename-case/","link":"","permalink":"http://yoursite.com/2018/08/27/filename-case/","excerpt":"","text":"※ 사소주의톰캣의 배포과정에서는 대소문자 구분을 하지않기 때문에 단순히 대소문자만 바꿔서 저장하면 인식을 못하는 경우가 있다.(파일을 못찾음)배포할때 이미 파일이 존재한다고 인지해서 바뀐 파일명에 대한 파일을 처리해주지 않는다.하지만 인식과정에서는 대소문자 구분을 해주기 때문에 당연히 해당 파일이 존재하지 않는다고 처리된다. -&gt; 해결방법: 다른 문자 추가해서 바꿨다가 다시 대소문자 바꾼 파일명으로 2번에 걸친 과정으로 바꿔준다.","categories":[{"name":"Programing","slug":"Programing","permalink":"http://yoursite.com/categories/Programing/"},{"name":"Web","slug":"Programing/Web","permalink":"http://yoursite.com/categories/Programing/Web/"}],"tags":[]},{"title":"Dynamic Web Project와 서버 연결하기","slug":"web-modules","date":"2018-08-27T14:01:41.000Z","updated":"2018-09-19T06:27:25.508Z","comments":true,"path":"2018/08/27/web-modules/","link":"","permalink":"http://yoursite.com/2018/08/27/web-modules/","excerpt":"","text":"Dynamic Web Project를 서버에서 실행시키기 위해서 서버와 프로젝트를 연결시켜줘야 한다. 방법1. Server 뷰에서 원하는 톰캣 서버를 우클릭하여 ‘Add and Remove’ 을 누른다. 후에 원하는 프로젝트를 ‘Add’ 해준다. (Front라는 이름의 프로젝트이다.) 방법2.Server 뷰에서 원하는 톰캣 서버를 더블클릭한다.노란색 박스로 표시된 ‘Add Web Module…’을 클릭하면 위와 같은 창이 뜬다. * Document Base: 실제 파일이 저장된 경로* Path: 논리적인 URL 에서 인정되는 경로 브라우저에서 Path에 작성해놓은 경로를 치면 Document Base에 작성된 프로젝트 안에서 파일을 찾는다.ex) Path 를 /lala 로 해놓았고 Front라는 프로젝트의 hi.html을 로드하려면,웹 브라우저의 url에 localhost:port번호/lala/hi.html 라고 작성하면 된다. 방법1로 추가시켰을 경우에는 Path가 자동으로 Document Base와 똑같이 설정된다. * Modules 설정 변경했으면, 서버를 재실행 시켜줘야한다. 추가만들어진 Web Project 폴더의 ‘Java Resource -&gt; Libraries’ 설명 Apache Tomcat v9.0 -&gt; 톰캣 런타임. java EE 스펙이 들어가 있다. JRE System Library -&gt; 기본 java 프로그래밍 라이브러리. java se스펙이 들어가있다. 프로젝트 오른쪽 클릭 - Build path : 실행환경 설정해주는 곳","categories":[{"name":"Programing","slug":"Programing","permalink":"http://yoursite.com/categories/Programing/"},{"name":"Web","slug":"Programing/Web","permalink":"http://yoursite.com/categories/Programing/Web/"}],"tags":[]},{"title":"톰캣 설치 및 적용","slug":"install-tomcat","date":"2018-08-27T12:45:43.000Z","updated":"2018-08-29T13:49:00.787Z","comments":true,"path":"2018/08/27/install-tomcat/","link":"","permalink":"http://yoursite.com/2018/08/27/install-tomcat/","excerpt":"","text":"톰캣 서버를 설치하고 이클립스에 올려 실행하고자 한다.기존에 이클립스를 Standard 버전을 쓰고 있었는데 해당 버전은 웹 프로젝트에 대한 지원이 안되기 때문에 톰캣 설치에 앞서 우선 이클립스 EE 버전을 새로 설치하려고 한다. Eclipse IDE for Java EE Developers 다운로드-&gt; 오른쪽 위에 ! 가 떠 있으면 선택해서 update 진행 (설치 후 installer 종료하면 update 다시 해야 함)-&gt; ! 사라지면 EE 버전 다운로드 진행 나는 SE 버전을 설치한지 몇 달 됐기 때문에 그 사이에 업데이트 사항이 생겨서..이 과정을 해줘야 했다. 이제 톰켓 웹 서버를 다운받아보자. 톰켓 웹 서버 다운로드http://tomcat.apache.org/- 왼쪽 Download 항목에서 Tomcat 9 클릭- 아래쪽 9.0.11 항목에서 Core: &nbsp;&nbsp;&nbsp;&nbsp;64-bit Windows zip 클릭해서 다운 윈도우에 올려서 사용하는게 아니라 이클립스에 올려서 사용할 예정이다.그러므로 톰캣 다운받을 때 ZIP 파일로 받아야한다. (WINDOW INSTALLER 이 아닌) 이제 마지막으로 다운 받은 톰캣을 이클립스에 올려보자. 이클립스에 Server Runtime 추가Window 메뉴- Preferences 항목&nbsp;&nbsp;&nbsp;&nbsp;- Server 항목&nbsp;&nbsp;&nbsp;&nbsp;- Runtime Environments&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- Add… 버튼 클릭&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- Apache Tomcat v9.0 선택&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- Browser 버튼 -&gt; 압축해제한 Tomcat Directory 선택하고 완료 해당 톰캣 폴더가 이클립스 내부 폴더로 복사됨서버가 설치된게 아니라 서버를 만들 수 있는 환경(서버 실행 환경)이 구축된 것이다. 이제 New -&gt; Server -&gt; Tomcat v9.0 Server 을 선택해 완료하면 하나의 서버가 만들어진다!","categories":[{"name":"Programing","slug":"Programing","permalink":"http://yoursite.com/categories/Programing/"},{"name":"Web","slug":"Programing/Web","permalink":"http://yoursite.com/categories/Programing/Web/"}],"tags":[{"name":"Tomcat","slug":"Tomcat","permalink":"http://yoursite.com/tags/Tomcat/"}]},{"title":"Singleton Pattern을 이용한 Ojdbc 활용 예제","slug":"jdbcEx-singleton-180823","date":"2018-08-23T05:16:56.000Z","updated":"2018-09-19T06:43:58.139Z","comments":true,"path":"2018/08/23/jdbcEx-singleton-180823/","link":"","permalink":"http://yoursite.com/2018/08/23/jdbcEx-singleton-180823/","excerpt":"","text":"이전 포스팅에서 DTO, DAO를 이용하여 Ojdbc를 활용한 DB작업을 했었다. 아래는 이전 포스팅의 UserDaoImpl 클래스 생성자의 한 부분이다. UserDaoImpl.java1234// 드라이버 로드Class.forName(DRIVER);// DB 연결conn = DriverManager.getConnection(URL, USERNAME, PASSWORD); 만약 여러 DAO 클래스를 작성한다면,위의 코드가(DB 연결객체 생성 코드) 계속 중복해서 쓰이기 때문에 DAO 클래스의 개수만큼 DB와의 연결이 수립된다.-&gt; 싱글톤 패턴으로 해결한다 우선 DB 연결객체를 싱글톤으로 사용할 수 있도록 따로 클래스를 만들어 준다. DBConn.java12345678910111213141516171819202122232425262728293031323334353637383940package dbutil;import java.sql.Connection;import java.sql.DriverManager;import java.sql.SQLException;public class DBConn &#123; // DB 연결 정보 public static final String DRIVER = \"oracle.jdbc.driver.OracleDriver\"; public static final String URL = \"jdbc:oracle:thin:@localhost:1521:xe\"; public static final String USERNAME = \"scott\"; public static final String PASSWORD = \"tiger\"; // DB 연결객체 private static Connection conn = null; // private 생성자 - 외부생성 불가 private DBConn()&#123; &#125; // Connection 객체 반환 = Singleton Pattern public static Connection getConnection() &#123; // DB 연결이 안되어있을 때만 동작 // getInstance()를 호출할 때까지 객체생성을 미룸 if (conn == null) &#123; try &#123; Class.forName(DRIVER); //드라이버 로드 // DB 연결객체 생성 conn = DriverManager.getConnection(URL, USERNAME, PASSWORD); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; return conn; &#125;&#125; 이제 아래의 클래스처럼 객체를 싱글톤으로 얻어 사용하면 된다. UserDaoImpl2.java1234567891011public class UserDaoImpl2 implements UserDao&#123; // DB 연결 객체 -&gt; 싱글톤 private static Connection conn = DBConn.getConnection(); // JDBC 객체 private PreparedStatement ps; private ResultSet rs; // ...(생략)...&#125;","categories":[{"name":"Programing","slug":"Programing","permalink":"http://yoursite.com/categories/Programing/"},{"name":"JDBC","slug":"Programing/JDBC","permalink":"http://yoursite.com/categories/Programing/JDBC/"}],"tags":[{"name":"Singleton","slug":"Singleton","permalink":"http://yoursite.com/tags/Singleton/"}]},{"title":"싱글톤 패턴이란?","slug":"singletonPattern","date":"2018-08-23T04:07:37.000Z","updated":"2018-08-31T16:02:17.066Z","comments":true,"path":"2018/08/23/singletonPattern/","link":"","permalink":"http://yoursite.com/2018/08/23/singletonPattern/","excerpt":"","text":"디자인 패턴, Design Pattern 잘 알려진 알고리즘의 형태 프로그램 설계 상 발생하는 문제(issue)에 대한 해답을 문서화한것 프로그램을 개발하면서 자주 마주치는 상황(문제점)을 해결하기 위한 설계 노하우를 적용시킨 형태의 알고리즘들 싱글톤 패턴, Singleton 객체를 여러 번 생성하더라도 하나의 인스턴스가 유지되도록 고안한 패턴 최초 객체생성(인스턴스화, new 객체()) 이후 생성자를 호출하더라도 최초에 만들어진 인스턴스를 반환하도록 설계한다 싱글톤 패턴 적용 위치 리소스를 많이 먹는 자원을 로드할 때 어플리케이션에서 지속적으로 사용하는 자원을 로드할 때 ( 드라이버로드, OJDBC 로드)( DB Connection )( 로그(Log) 객체 ) &lt;싱글톤 패턴의 장점&gt; 객체의 로딩 시간이 빨라진다 (단, 첫번째는 빠르지 않다) 인스턴스가 프로그램 실행 중 절대적으로 한 개만 존재한다 &lt;싱글톤 패턴의 단점&gt; 싱글톤 인스턴스가 너무 많은 곳에서 사용되거나 너무 많은 데이터를 공유해주는 경우 인스턴스 들의 결합도가 높아진다. ** 개방 - 폐쇄 원칙 (객체지향 설계 원칙 중 한가지) : 응집도는 높히고/ 결합도는 낮춘다.","categories":[{"name":"Programing","slug":"Programing","permalink":"http://yoursite.com/categories/Programing/"}],"tags":[]},{"title":"static 블록","slug":"static-block","date":"2018-08-23T03:31:33.000Z","updated":"2018-08-31T16:01:50.097Z","comments":true,"path":"2018/08/23/static-block/","link":"","permalink":"http://yoursite.com/2018/08/23/static-block/","excerpt":"","text":"static 블록, 초기화 블록, Initialization Block 클래스 코드가 처음 로드될 때 딱 한번만 수행하는 코드 블록 객체생성(인스턴스화, 생성자호출)과는 무관하게 한번 수행한다(사전 준비작업단계에서 수행) 클래스변수( =정적변수 =static 변수) 초기화에 사용됨 단순 초기화(값 대입)가 아닌 예외처리같은 추가작업을 코드로 적을 수 있게 해준다 (참고)클래스로드 및 객체 생성 순서 클래스로드 (클래스 로더(JVM에 존재)가 수행) (메모리 영역 중 클래스 영역에 로드) 클래스변수 생성 static 블록 수행 ———— 로드 완료 ————(이후에는 동적인 영역) 이후 준비(로드)된 클래스의 생성자 호출을 통해 인스턴스를 생성 클래스 로더의 수행 절차 바이트 코드를 분석 프로그램에서 사용된 클래스를 JRE 라이브러리에서 .class 파일로 찾기 (ex&gt; System.out.print 인 경우 System 이라는 클래스 파일을 JRE 라이브러리에서 찾음) 없으면 CLASSPATH로 지정된 폴더에서 .class 찾기 찾은 이후, 문법검사 (올바른 문법의 바이트코드인지 검증) 올바른 문법이면, .class 파일을 메모리로 로드 클래스 블록(정적필드, 정적메소드) 처리 static 초기화 블록 수행 준비 작업이 끝나면 모두 메모리에 로드되어 있음. (미리 어디있는지 다 찾아서 연결점을 만들어 놓는다고 생각)이후 main 메소드를 한 줄씩 읽으며 실행한다.","categories":[{"name":"Programing","slug":"Programing","permalink":"http://yoursite.com/categories/Programing/"}],"tags":[]},{"title":"DAO를 이용한 Ojdbc 활용 예제(USER)","slug":"jdbcEx-user-180822","date":"2018-08-23T03:26:42.000Z","updated":"2018-09-19T06:43:54.465Z","comments":true,"path":"2018/08/23/jdbcEx-user-180822/","link":"","permalink":"http://yoursite.com/2018/08/23/jdbcEx-user-180822/","excerpt":"","text":"JDBC를 이용해 USERTEST테이블에 접근하여 몇 가지 쿼리를 수행한다. (UserDao 클래스 참고) 이전 포스팅의 예제에서는 main 함수가 있는 클래스에 DB 연결, SQL 문 수행 등 모든 작업이 한 번에 이루어 졌었다.이번에는 DAO를 이용하여 코드를 작성하였다.메인 함수 실행부와 DB 연결 및 SQL작성부를 분리시킨다. * DAO: 데이터베이스에 수행할 SQL 문을 하나의 메소드의 기능으로 구현하여 모아놓은 객체 [패키지 구성] user ├ dao │ ├ UserDao.java (인터페이스) │ └ UserDaoImpl.java │ ├ dto │ └ User.java └ ex &nbsp;&nbsp;&nbsp;&nbsp;└ UserEx.java UserDao 인터페이스12345678910111213141516171819202122package user.dao;import java.util.List;import user.dto.User;public interface UserDao &#123; //UserTest 테이블 전체 조회 // idx 정렬 public List&lt;User&gt; selectAll(); // idx를 이용한 UserTest 조회 // 1명이 조회되도록 한다 public User selectByIdx(int idx); // User 삽입 public void insertUser(User insertUser); // idx를 이용한 UserTest 삭제 public void deleteByIdx(int idx);&#125; UserDaoImpl.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187package user.dao;import java.sql.Connection;import java.sql.DriverManager;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;import java.util.ArrayList;import java.util.List;import user.dto.User;public class UserDaoImpl implements UserDao&#123; // DB 연결 정보 private final String DRIVER = \"oracle.jdbc.driver.OracleDriver\"; private final String URL = \"jdbc:oracle:thin:@localhost:1521:xe\"; private final String USERNAME = \"scott\"; private final String PASSWORD = \"tiger\"; // DB 연결 객체 private Connection conn; // JDBC 객체 private PreparedStatement ps; private ResultSet rs; public UserDaoImpl() &#123; try &#123; // 드라이버 로드 Class.forName(DRIVER); conn = DriverManager.getConnection(URL, USERNAME, PASSWORD); // 오토커밋 설정(기본값 : true) // 오토커밋 시 중간에 에러나서 프로그램종료되면 자동커밋, 데이터 깨질 수 있음 conn.setAutoCommit(false); // 이러면 commit, rollback 관리를 명시적으로 해줘야함 &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; @Override public List&lt;User&gt; selectAll() &#123; String sql = \"SELECT * FROM userTest ORDER BY idx\"; List&lt;User&gt; userList = new ArrayList&lt;&gt;(); try &#123; ps = conn.prepareStatement(sql); rs = ps.executeQuery(); while(rs.next()) &#123; User user = new User(); user.setIdx(rs.getInt(\"idx\")); user.setUserid(rs.getString(\"userid\")); user.setName(rs.getString(\"name\")); userList.add(user); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; rs.close(); ps.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; return userList; &#125; @Override public User selectByIdx(int idx) &#123; String sql = \"SELECT * FROM userTest WHERE idx = ?\"; User user = null; try &#123; ps = conn.prepareStatement(sql); ps.setInt(1, idx); rs = ps.executeQuery(); user = new User(); if(rs.next()) &#123; user.setIdx(rs.getInt(\"idx\")); user.setName(rs.getString(\"name\")); user.setUserid(rs.getString(\"userid\")); &#125; else &#123; System.out.println(\"** 조회: 해당 IDX에 해당하는 유저가 없습니다.\"); return null; &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; rs.close(); ps.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; return user; &#125; @Override public void insertUser(User insertUser) &#123; String userId = insertUser.getUserid(); String userName = insertUser.getName(); String sql = \"INSERT INTO userTest(idx, userid, name) VALUES (userTest_SQ.nextval,?,?)\"; String sql2 = \"SELECT COUNT(*) FROM userTest WHERE userid = upper(?)\"; try &#123; // 중복 아이디 체크 PreparedStatement ps2 = conn.prepareStatement(sql2); ps2.setString(1, userId); rs = ps2.executeQuery(); rs.next(); // 해당 아이디가 있다면 추가 X if(rs.getInt(1) &gt; 0) &#123; System.out.println(\"** 삽입: 같은 ID 가 존재합니다.\"); &#125; else &#123; // user 추가 ps = conn.prepareStatement(sql); ps.setString(1, userId); ps.setString(2, userName); ps.executeUpdate(); &#125; conn.commit(); // 명시적으로 커밋하기 &#125; catch (SQLException e) &#123; e.printStackTrace(); try &#123; conn.rollback(); // 예외 발생 시 롤백 &#125; catch (SQLException e1) &#123; e1.printStackTrace(); &#125; &#125; finally &#123; try &#123; rs.close(); ps.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; @Override public void deleteByIdx(int idx) &#123; String sql = \"DELETE userTest WHERE idx = ?\"; try &#123; ps = conn.prepareStatement(sql); ps.setInt(1, idx); if( ps.executeUpdate() == 0) &#123; System.out.println(\"** 삭제: 해당 IDX에 해당하는 유저가 없습니다.\"); &#125; conn.commit(); // 명시적으로 커밋하기 &#125; catch (SQLException e) &#123; e.printStackTrace(); try &#123; conn.rollback(); // 예외 발생 시 롤백 &#125; catch (SQLException e1) &#123; e1.printStackTrace(); &#125; &#125; finally &#123; try &#123; ps.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; ** 메소드 안의 catch문에서 자원 해제할 때 conn은 close()하면 안된다. 연결 객체를 해제해버리면 다른 메소드에서 접근 할 수 없다.","categories":[{"name":"Programing","slug":"Programing","permalink":"http://yoursite.com/categories/Programing/"},{"name":"JDBC","slug":"Programing/JDBC","permalink":"http://yoursite.com/categories/Programing/JDBC/"}],"tags":[]},{"title":"코드블럭 스타일 바꾸기","slug":"codeBlockSpace","date":"2018-08-23T01:17:45.000Z","updated":"2018-08-29T15:14:48.897Z","comments":true,"path":"2018/08/23/codeBlockSpace/","link":"","permalink":"http://yoursite.com/2018/08/23/codeBlockSpace/","excerpt":"","text":"코드블럭의 탭 간격 바꾸기_config.yml 파일에서12highlight: tab_replace: &apos; &apos; tab_replace:에 원하는 만큼의 간격을 넣어준다. 간단하게 바꿀 수 있는 거였는데, 별로의 css 파일을 수정하거나 플러그인을 따로 설치하는건가 싶어 엄청 헤맸다.. 코드블럭의 하이라이트 스타일 바꾸기현재 HUEMAN 테마를 사용 중이다. themes\\hueman\\_config.yml 파일을 열어12customize: highlight: highlight: 에 원하는 스타일명을 넣어주면 된다. 바꿔주려는 명은 css\\highlight에 존재하는 파일명중 하나로 바꿔주면 된다.","categories":[],"tags":[]},{"title":"PreparedStatement을 이용한 Ojdbc 사용 예제","slug":"jdbcEx-180821","date":"2018-08-22T14:23:12.000Z","updated":"2018-09-19T06:44:02.331Z","comments":true,"path":"2018/08/22/jdbcEx-180821/","link":"","permalink":"http://yoursite.com/2018/08/22/jdbcEx-180821/","excerpt":"","text":"DB의 emp 테이블에서 job = ‘SALESMAN’ 인 컬럼들을 조회하여 출력한다.출력 시 Emp 클래스를 이용하여 출력한다. Emp는 DTO클래스로 따로 만들었다. (사용 필드, toString, getter/setter) ※ PreparedStatement 사용 : 더 안전하고 활용도 큼 -&gt; Statement 대신 이걸로 쓰기! 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485package ojdbc;import java.sql.Connection;import java.sql.DriverManager;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;import java.util.ArrayList;import java.util.List;import dto.Emp;public class OjdbcEx_04 &#123; // OJDBC DRIVER private static final String DRIVER = \"oracle.jdbc.driver.OracleDriver\"; // DB 연결 정보 private static final String URL = \"jdbc:oracle:thin:@localhost:1521:xe\"; private static final String USERNAME = \"scott\"; private static final String PASSWORD = \"tiger\"; // OJDBC 객체 private static Connection conn; // DB 연결객체 private static PreparedStatement ps; // SQL 수행객체 private static ResultSet rs; // 조회결과 public static void main(String[] args) &#123; try &#123; // 드라이버 로드 Class.forName(DRIVER); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; // ?없어도 PreparedStatement 사용가능 String sql = \"SELECT * FROM emp WHERE job = ? ORDER BY empno\"; try &#123; conn = DriverManager.getConnection(URL, USERNAME, PASSWORD); ps = conn.prepareStatement(sql); // SQL의 첫번째 ? 에 데이터를 넣는다 ps.setString(1, \"SALESMAN\"); // SQL 쿼리 수행 rs = ps.executeQuery(); // 쿼리 결과를 담은 List List&lt;Emp&gt; list = new ArrayList&lt;&gt;(); // 쿼리 결과 list 에 담기 while(rs.next()) &#123; //데이터가 없으면 false // 매번 emp 객체 생성해서 해당 객체를 list 에 넣는다 Emp emp = new Emp(); emp.setEmpno(rs.getInt(\"empno\")); emp.setEname(rs.getString(\"ename\")); emp.setJob(rs.getString(\"job\")); emp.setMgr(rs.getInt(\"mgr\")); emp.setHiredate(rs.getDate(\"hiredate\")); emp.setSal(rs.getInt(\"sal\")); emp.setComm(rs.getInt(\"comm\")); emp.setDeptno(rs.getInt(\"deptno\")); list.add(emp); &#125; // 쿼리 결과 출력 for( Emp e : list) &#123; System.out.println(e); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; rs.close(); ps.close(); conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; ** 드라이버 로드해주는 코드는 ojdbc4.jar 인가 ojdbc6.jar 부터는 자동으로 해줘서 안써도 실행은 된다고 한다.","categories":[{"name":"Programing","slug":"Programing","permalink":"http://yoursite.com/categories/Programing/"},{"name":"JDBC","slug":"Programing/JDBC","permalink":"http://yoursite.com/categories/Programing/JDBC/"}],"tags":[{"name":"DAO","slug":"DAO","permalink":"http://yoursite.com/tags/DAO/"},{"name":"DTO","slug":"DTO","permalink":"http://yoursite.com/tags/DTO/"},{"name":"PreparedStatement","slug":"PreparedStatement","permalink":"http://yoursite.com/tags/PreparedStatement/"}]},{"title":"DAO & DTO","slug":"DAODTO","date":"2018-08-22T13:26:20.000Z","updated":"2018-08-22T14:38:32.903Z","comments":true,"path":"2018/08/22/DAODTO/","link":"","permalink":"http://yoursite.com/2018/08/22/DAODTO/","excerpt":"","text":"DTO, Data Transmission Object(프레임워크 단에서 주로 쓰이는 용어) 데이터 전송 객체 VO (Value Object) 계층간 데이터 교환을 위한 자바 클래스( Java Beans: , JAVA EE(EnterPrise : 웹이나 대규모 플젝할 때 쓰임, (JAVA SE (기본))) - 이쪽에서 주로 사용하는 용어) DTO 클래스 명은 테이블의 이름과 같게 하는 것이 좋다 멤버 필드는 모두 private(데이터베이스 테이블의 컬럼명과 같게 하는 것이 좋다) 메소드는 getter, setter, toString() 만 작성 ** VO : 데이터로만 이뤄진 객체 &nbsp;&nbsp;&nbsp;&nbsp;DTO : VO 랑 거의 같은 의미. 전송을 목적으로 했을 때 DTO 라고 씀 DAO, Data Access Object Database의 데이터에 접근하기 위한 객체 데이터베이스에 수행할 SQL 문을 하나의 메소드의 기능으로 구현하여 모아놓은 객체","categories":[{"name":"Programing","slug":"Programing","permalink":"http://yoursite.com/categories/Programing/"},{"name":"JDBC","slug":"Programing/JDBC","permalink":"http://yoursite.com/categories/Programing/JDBC/"}],"tags":[{"name":"DAO","slug":"DAO","permalink":"http://yoursite.com/tags/DAO/"},{"name":"DTO","slug":"DTO","permalink":"http://yoursite.com/tags/DTO/"}]}]}