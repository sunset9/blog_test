{"meta":{"title":"Don't forget","subtitle":"lazy","description":null,"author":"Hae Jin","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"의존성 주입","slug":"di","date":"2018-11-14T14:21:00.000Z","updated":"2018-11-19T14:24:12.428Z","comments":true,"path":"2018/11/14/di/","link":"","permalink":"http://yoursite.com/2018/11/14/di/","excerpt":"","text":"의존성, Dependency: 특정 객체가 작동하기위해서 필요한 외부 객체와의 연결 ex) public class EmpController { &nbsp;&nbsp;&nbsp; // EmpController클래스는 EmpService에 의존적이다&nbsp;&nbsp;&nbsp; private EmpService empService = new EmpService(); &nbsp;&nbsp;&nbsp;// EmpController클래스는 EmpDao에 의존성을 가지고있다&nbsp;&nbsp;&nbsp; private EmpDao empDao = new EmpDao(); } DI, Dependency Injection 의존성 주입 의존성을 객체가 직접 발생시키지 않고 외부의 도움을 받아 발생하는 것 IoC, Inversion of Control 제어의 역전 개발 흐름의 제어권이 역적되었다는 뜻 프로그램의 흐름 제어를 스프링 프레임워크가 담당한다","categories":[{"name":"Programing","slug":"Programing","permalink":"http://yoursite.com/categories/Programing/"},{"name":"Spring","slug":"Programing/Spring","permalink":"http://yoursite.com/categories/Programing/Spring/"}],"tags":[]},{"title":"스프링 설치 & 환경 구축","slug":"setup-Spring","date":"2018-11-13T13:19:47.000Z","updated":"2018-11-19T13:49:32.999Z","comments":true,"path":"2018/11/13/setup-Spring/","link":"","permalink":"http://yoursite.com/2018/11/13/setup-Spring/","excerpt":"","text":"1. STS Tools Plugin 설치 이클립스 - HELP -&gt; Eclipse MarktetPlace -&gt; sts 검색 -&gt; install 설치 후 이클립스 재시작 2. Eclipse MVC Spring Project 생성 설치 완료 후 스프링 프로젝트 생성File -&gt; New -&gt; Other -&gt; Spring -&gt; Spring Legacy Project 선택 Spring MVC Project 선택 top-level 패키지 명 입력 3. pom.xml 수정스프링: 4.3.20 버전,Java: 8버전 을 쓸 예정이므로아래 사진과 같이 pom.xml 파일을 수정해준다. 4. JDK 버전 변경 - Build Path 수정 위에서 설정한 pom.xml 과 일치하게 build path 에서 Java 버전을 수정해주어야 한다. Project Facets -&gt; Java -&gt; 1.8 버전 선택 후 Apply ** 확인은 Build Path에서 JRE Library 버전을 확인","categories":[{"name":"Programing","slug":"Programing","permalink":"http://yoursite.com/categories/Programing/"},{"name":"Spring","slug":"Programing/Spring","permalink":"http://yoursite.com/categories/Programing/Spring/"}],"tags":[]},{"title":"invalid LOC header 에러 해결","slug":"invalid-LOC-header","date":"2018-11-13T13:11:36.000Z","updated":"2018-11-19T13:34:29.555Z","comments":true,"path":"2018/11/13/invalid-LOC-header/","link":"","permalink":"http://yoursite.com/2018/11/13/invalid-LOC-header/","excerpt":"","text":"서버 시작 시 이클립스 콘솔에 예외메시지 중에서 invalid LOC header 라는 문구가 보일 때 MAVEN 에러가 난 것 pom.xml에 설정한 버전의 라이브러리를 다운 받을 때 잘못된 경우에 발생하는 에러 해결 방법 이클립스를 끈다 C:\\Users\\사용자폴더.m2\\repository 폴더 삭제 이클립스를 켠다 Progress 탭의 반응이 없을 때까지 기다린다 해결! 안되면 1부터 다시…그래도 안되면 설정에 문제가 있는 것. 다시 확인해야함","categories":[{"name":"Programing","slug":"Programing","permalink":"http://yoursite.com/categories/Programing/"},{"name":"Web","slug":"Programing/Web","permalink":"http://yoursite.com/categories/Programing/Web/"}],"tags":[]},{"title":"jQuery를 이용한 Ajax","slug":"jquery-ajax","date":"2018-11-03T11:09:53.000Z","updated":"2018-11-19T11:12:58.733Z","comments":true,"path":"2018/11/03/jquery-ajax/","link":"","permalink":"http://yoursite.com/2018/11/03/jquery-ajax/","excerpt":"","text":"jQuery를 이용한 Ajax XHR을 이용한 순수 자바스크립트 Ajax는 크로스 브라우징이 안됨** 크로스 브라우징: 하나의 코드로 다양한 브라우저에서 동작 Ajax의 응답을 jQuery DOM을 이용하여 손쉽게 적용가능하다 jQuery Ajax API $객체.load(url [,data] [,complete]); $.get(url [,data] [,sucess] [,dataType]); $.post(url [,data] [,sucess] [,dataType]); $.ajax(url [,settings]); $.ajax([settings]); $객체.load(url [,data] [,complete]); 응답 텍스트를 .load 함수가 시작된 $객체에 반영한다 응답 데이터를 $객체의 자식요소로 삽입한다 추가적인 기능을 수행하려면 complete 매개변수에 지정된 콜백함수를 통해 작성한다 ex) $(“#resultLayout”).load(“ajax_ok.jsp”); url: Ajax 통신 요청 url쿼리스트링을 붙여서 GET method 통신으로 사용하기도 한다 data: 요청 파라미터JSON Object 또는 String 타입 JSON Object로 입력 시 POST 통신 String으로 입력 시 GET 통신 complete: 요청 완료 후 응답 callback functionfunction(&nbsp;&nbsp; String responseText , // 응답 텍스트&nbsp;&nbsp; String textStatus, // 응답 상태코드 메시지&nbsp;&nbsp; jqXHR jqXHR) // jQuery 객체타입의 XHR $.get(url [,data] [,sucess] [,dataType]);$.post(url [,data] [,sucess] [,dataType]); url: 요청 url data: 요청 파라미터JSON, String sucess: 요청 응답 성공 시 callback functionfunction(&nbsp;&nbsp; PlainObject data, // 응답데이터 &nbsp;&nbsp; String textStatus, &nbsp;&nbsp; jqXHR jqXHR) dataType: 응답 메시지의 데이터 타입xml, json, script, text, html(설정하지 않으면 알아서 판단하지만 대부분 text로 받음) $.ajax(url [,settings]);$.ajax([settings]); &lt;- 사용 추천settings 옵션 type* : “GET”(기본값) | “POST”jQuery 1.9.0 이전 버전을 지원하는 설정값 (method 항목과 같이 볼 것) url* : String 타입/ AJAX 통신 요청 URL data* : PlainObject, String, Array 타입/ 요청 파라미터 dataType* : “xml” | “json” | “script” | “html” | “text”응답 데이터의 처리방식(데이터형식)지정된 형식에 맞게 응답받은 데이터를 파싱(추출)함 sucess* : function(Anything data, String textStatus, jqXHR jqXHR)요청 성공 시 호출될 callback 함수- data : 응답받은 데이터가 넘어온다- textStatus : 상태코드에 대한 문자열- jqXHR : jqXHR를 직접사용하고 싶다면 해당 jqXHR객체를 사용(jQuery 객체로 온다) error* : function(jqXHR jqXHR, String textStatus, String errorThrown)요청 실패 시 호출될 callback 함수 async : true(기본값-비동기) | false비동기 처리 설정 beforeSend : function(jqXHR jqXHR, Object settings)요청 전 처리할 기능 작성 complete : function(jqXHR jqXHR, String textStatus)요청 완료 후 처리할 기능 작성 (성공/실패와 무관하게 동작한다) method : “GET” | “POST” | “PUT” | “DELETE” | …RESTful API의 method를 지정할 수 있게 해주는 설정 statusCode : PlainObject 타입/ 응답 상태 코드에 따른 처리 코드ex)statusCode: {&nbsp;&nbsp; 404: function(){&nbsp;&nbsp; }&nbsp;&nbsp; ,403: function(){&nbsp;&nbsp; }&nbsp;&nbsp; ,500: function(){&nbsp;&nbsp; }}","categories":[{"name":"Programing","slug":"Programing","permalink":"http://yoursite.com/categories/Programing/"},{"name":"jQuery","slug":"Programing/jQuery","permalink":"http://yoursite.com/categories/Programing/jQuery/"}],"tags":[]},{"title":"마샬링, 언마샬링","slug":"marshalling","date":"2018-11-02T11:06:46.000Z","updated":"2018-11-19T11:09:06.166Z","comments":true,"path":"2018/11/02/marshalling/","link":"","permalink":"http://yoursite.com/2018/11/02/marshalling/","excerpt":"","text":"직렬화, Serialization 스트림을 통해 데이터를 전송하기 위해 데이터를 1바이트 단위로 잘게 나누는 것 역직렬화, Deserialization 스트림을 통과해 온 데이터(1바이트 스트림)를 원본형태로 결합하는 것 마샬링, Marshalling- 데이터를 전달하기 위해 특정 표기법으로 변환하는 것- 주로 JSON형식을 사용한다- XML을 이용하기도 한다 언마샬링, Unmarshalling JSON형식으로 전달된 데이터를 해당 시스템이 사용하는 형식으로 변환하는 것(복원)","categories":[{"name":"Programing","slug":"Programing","permalink":"http://yoursite.com/categories/Programing/"},{"name":"Web","slug":"Programing/Web","permalink":"http://yoursite.com/categories/Programing/Web/"}],"tags":[]},{"title":"AJAX / XHR 객체","slug":"ajax-xhr","date":"2018-11-01T10:57:45.000Z","updated":"2018-11-19T11:05:43.658Z","comments":true,"path":"2018/11/01/ajax-xhr/","link":"","permalink":"http://yoursite.com/2018/11/01/ajax-xhr/","excerpt":"","text":"AJAX, Asyschronous JavaScript + XML 비동기식 자바 스크립트 with XML JSON : JavaScript Object Notation : 자바스크립트 객체 표기법 자바스크립트 기반의 XML을 이용한 비동기 HTTP통신 자바스크립트로 HTTP 요청을 보내고 XML로 응답을 받는 기술** 요즘엔 XML 대신 JSON을 사용한다 요청보내기, 응답받기 모두 자바스크립트 코드로 작성해야 한다 XMLHttpRequest(XHR) 자바스크립트 내장 객체를 이용한다 Ajax 동작 순서 XMLHttpRequest 객체를 이용한 요청(Request) 서버로부터 보내진 XML문서(JSON데이터)를 응답(Response) 받음 XHR 객체가 받는다 자바스크립트(jQuery)코드를 이용한 응답 데이터 처리 브라우저 화면에 반영한다 XHR 객체 속성(property) readyState: XHR 객체는 준비-전송-완료 단계를 거친다. readyState는 각 단계를 나타내는 코드 0 : UNSENT - open() 호출 전 (객체만 생성한 단계) 1 : OPENED - open() 호출 후 응답받기 전 2 : HEADERS_RECEIVED - send() 호출, 응답받기 전 3 : LOADING - 다운로드 중(response 받는 중간) 4 : DONE - XHR동작(요청,응답) 완료 ** LOADING 상태 돌입하면서 XHR.onprogress 이벤트가 발생한다** DONE 상태 시 XHR.onload 이벤트가 발생한다 onreadystatechange: readyState가 변경될 때마다 발생하는 이벤트 처리 코드callback 형태로 함수를 지정한다 responseText: 응답데이터를 String 타입으로 추출하는 속성 responseXML: 응답데이터를 XML객체 타입으로 추출하는 속성 status: HTTP 응답 상태 코드readyState:DONE 이후 응답상태에 따른 처리 설정 시 이용 statusText: HTTP 응답 상태 메세지ex) 404. Not Found. XHR 객체 함수 void open(String method, String url, [, booleand asynch]);: 요청 초기화 요청 정보 설정 함수 method : HTTP 요청 메소드 (GET, POST) url : 접속 URL asynch : 동기(false), 비동기(true) 설정 [기본값 : true]** asynch를 동기(false)로 설정하면 요청에 대한 응답이 완료될 때까지 대기상태(BLOCKED)가 된다** url은 같은 도메인이어야 한다localhost:8088에서 요청하면 같은 localhost:8088에만 요청을 보내야한다 (cross-domain issue) void send(null);: GET 요청 전송 함수 (url에 쿼리스트링을 추가한다) void send(params);: POST 요청 전송 함수params에 쿼리스트링 형식의 문자열을 추가한다 (select 문만 쓸 것같다 -&gt; GET 방식)(update, insert, delete를 쓸 것 같다 -&gt; POST 방식을 쓰는게 일반적)","categories":[{"name":"Programing","slug":"Programing","permalink":"http://yoursite.com/categories/Programing/"},{"name":"Web","slug":"Programing/Web","permalink":"http://yoursite.com/categories/Programing/Web/"}],"tags":[]},{"title":"파일 다운로드","slug":"filedownload","date":"2018-10-01T13:34:08.000Z","updated":"2018-10-01T13:56:43.891Z","comments":true,"path":"2018/10/01/filedownload/","link":"","permalink":"http://yoursite.com/2018/10/01/filedownload/","excerpt":"","text":"이전에는 파일 업로드하는 부분을 구현해봤으니이번에는 서버에 업로드된 파일을 다운로드하는 파트를 구현해보았다. 선처리[DB]아래와 같이 DB 테이블을 생성해두고, 이전에 파일 업로드를 구현하면서 업로드 로그를 해당 테이블에 삽입해두었다. [DTO]DB구조와 동일하게 작성 [DAO]적당히 구현 [VIEW]1.업로드된 파일의 리스트를 뿌려준다.2.해당 파일명을 선택하면 &lt;a&gt; 태그를 통해 fileno을 쿼리스트링으로 넘겨준다. VIEW 로부터 받은 fileno을 이용하여, 다운로드를 진행해준다. SERVLET fileno을 통해 DB를 조회 -&gt; 서버에 저장된 이름을 가져와서 찾는다. Response메세지 Header 설정해주기! 다운로드될 파일은 원본 이름으로 지정해준다. 누르면 바로 다운로드 되도록 한다.(크롬의 경우, 파일타입에 따라 바로 다운로드하지 않고 뷰만 제공해주기도 한다.) FileUploadCosServlet.java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677package file;import java.io.File;import java.io.FileInputStream;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import dao.FileUploadDao;import dao.FileUploadDaoImpl;import dto.UploadFile;@WebServlet(\"/file/download\")public class FileDownloadServlet extends HttpServlet&#123; private static final long serialVersionUID = 1L; private FileUploadDao fDao = new FileUploadDaoImpl(); @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; String param = req.getParameter(\"fileno\"); int fileno = 0; if(param !=null &amp;&amp; !\"\".equals(param)) &#123; fileno = Integer.parseInt(param); &#125; // 다운로드 대상 파일 정보 찾기 UploadFile downfile = fDao.selectByFileno(fileno); // 다운로드 파일 찾기 File file = new File(getServletContext().getRealPath(\"upload\"), downfile.getStored_name()); // 파일이 존재할 때만 동작 if(file.exists() &amp;&amp; file.isFile()) &#123; // 응답 정보 설정(Response 메시지header 수정) // key - value 타입 (value는 String으로!) // 응답 본문 길이 resp.setHeader(\"Content-Length\", String.valueOf(file.length())); // 응답 파일 저장 위치 지정 resp.setHeader(\"Content-Disposition\", \"attachment;fileName=\"+new String(downfile.getOrigin_name().getBytes(\"UTF-8\"), \"8859_1\")+\";\"); // text/html;charset=utf-8 (기본설정) // 다운받는 내용을 바이너리파일로 인식시키기 ( 별도의 형식으로 마음대로 해석하지 못하게, 이미지인지 pdf 인지 무시) resp.setContentType(\"application/octet-stream\"); // 파일 입력 스트림 (서버 로컬 저장소(하드디스크)) InputStream is = new FileInputStream(file); // 파일 출력 스트림(브라우저) OutputStream os = resp.getOutputStream(); // 바이트단위 byte[] buf = new byte[4096]; int len = -1; while( (len=is.read(buf))!= -1 ) &#123; os.write(buf, 0, len); &#125; os.flush(); is.close(); os.close(); &#125; else &#123; System.out.println(\"파일 없음\"); &#125; &#125;&#125;","categories":[{"name":"Programing","slug":"Programing","permalink":"http://yoursite.com/categories/Programing/"},{"name":"Web","slug":"Programing/Web","permalink":"http://yoursite.com/categories/Programing/Web/"}],"tags":[]},{"title":"파일 업로드 (COS Lib활용)","slug":"fileupload-02","date":"2018-10-01T13:25:35.000Z","updated":"2018-10-01T13:53:11.833Z","comments":true,"path":"2018/10/01/fileupload-02/","link":"","permalink":"http://yoursite.com/2018/10/01/fileupload-02/","excerpt":"","text":"commons 라이브러리보다 훨씬 쉽게 구현이 가능하다.우선 세팅해줘야 하는 값들이 별로 없고, MultipartRequest 객체를 생성하는 걸로 파일 업로드 처리가끝난다. VIEW이전 포스팅과 동일하게 구현 SERVLETFileUploadCosServlet.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697package file;import java.io.File;import java.io.IOException;import java.io.PrintWriter;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import com.oreilly.servlet.MultipartRequest;import com.oreilly.servlet.multipart.DefaultFileRenamePolicy;import com.oreilly.servlet.multipart.FileRenamePolicy;import dao.FileUploadDao;import dao.FileUploadDaoImpl;import dto.UploadFile;@WebServlet(\"/file/cos/upload\")public class FileUploadCosServlet extends HttpServlet &#123; private static final long serialVersionUID = 1L; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; req.getRequestDispatcher(\"/file/cos/fileUpload.jsp\").forward(req, resp); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; // HTTP 요청/응답 인코딩 설정 req.setCharacterEncoding(\"UTF-8\"); resp.setContentType(\"text/html;charset=utf-8\"); // 응답객체 출력 스트림 PrintWriter out = resp.getWriter(); // --- MultipartRequest 생성자의 매개변수 준비 --- // 1. 요청 객체 // 따로 만들 필요 없음 // 2. 파일 저장 위치 // String으로 서버의 실제 경로 지정 String saveDirectory = getServletContext().getRealPath(\"cos/upload\");// System.out.println(saveDirectory); // 3. 업로드 제한 사이즈 int maxPostSize = 10 * 1024 * 1024; // 10MB 제한 // 4. 인코딩 // 업로드 정보 인코딩 방식 String encoding = \"UTF-8\"; // 5. 중복 파일이름 정책 // DefaultFileRenamePolicy는 중복파일이 있으면 // 파일이름 뒤에 숫자를 추가하고 1부터 증가시킨다 FileRenamePolicy policy = new DefaultFileRenamePolicy(); // ----------------------------------------- // MultipartRequest 객체 생성 // 파일 업로드 처리 MultipartRequest mul = new MultipartRequest(req, saveDirectory, maxPostSize, encoding, policy); // ---- 업로드 정보 관리 ---- // \"title\", \"uploadFile\" 은 모두 form 태그에서 name 으로 지정해준 값 out.println(\"--- 전달 파라미터 ---&lt;br&gt;\"); out.println(mul.getParameter(\"title\")); out.println(\"&lt;br&gt;&lt;br&gt;--- 업로드파일(저장된 실제 경로) ---&lt;br&gt;\"); File up = mul.getFile(\"uploadFile\"); out.println(up.toString()); out.println(\"&lt;br&gt;&lt;br&gt;--- 저장된 파일이름 ---&lt;br&gt;\"); out.println(mul.getFilesystemName(\"uploadFile\")); out.println(\"&lt;br&gt;&lt;br&gt;--- 원본 파일이름 ---&lt;br&gt;\"); out.println(mul.getOriginalFileName(\"uploadFile\")); out.println(\"&lt;br&gt;&lt;br&gt;--- 파일 형식 ---&lt;br&gt;\"); out.println(mul.getContentType(\"uploadFile\")); // --------------------- // DB에 저장 UploadFile uploadFile = new UploadFile(); // 저장된 파일 이름 uploadFile.setStored_name(mul.getFilesystemName(\"uploadFile\")); // 원본 파일 이름 uploadFile.setOrigin_name(mul.getOriginalFileName(\"uploadFile\")); FileUploadDao fDao = new FileUploadDaoImpl(); fDao.insert(uploadFile); &#125;&#125;","categories":[{"name":"Programing","slug":"Programing","permalink":"http://yoursite.com/categories/Programing/"},{"name":"Web","slug":"Programing/Web","permalink":"http://yoursite.com/categories/Programing/Web/"}],"tags":[]},{"title":"COS 라이브러리 - MultipartRequest객체","slug":"cos-library-upload","date":"2018-10-01T00:30:39.000Z","updated":"2018-10-01T13:54:49.550Z","comments":true,"path":"2018/10/01/cos-library-upload/","link":"","permalink":"http://yoursite.com/2018/10/01/cos-library-upload/","excerpt":"","text":"COS라이브러리를 활용해 파일 업로드를 구현하기 전에COS라이브러리에서 사용할 MultipartRequest 객체에 대해 알아보도록 하자. COS 라이브러리 파일 업로드 com.oreilly.servlet.MultipartRequest 객체 이용 객체의 생성자를 통해 업로드 제한 설정을 한다 MultipartRequest 생성자123456789public MultipartRequest ( HttpServletRequset request, //요청 객체 String saveDirectory, // 파일 저장 위치 int maxPostSize, // 업로드 제한 사이즈 String encoding, // 인코딩 FileRenamePolicy policy // 중복 파일이름 처리정책) throws IOException; MultipartRequest 주요 메소드 String getParameter(String name)요청 파라미터 얻기 String[] getParameterValues(String name)요청 파라미터를 배열로 얻기 Enumeration getParameterNames()요청 파라미터의 name들을 열거체로 얻기 File getFile(String name)업로드된 파일 객체 얻기 Enumeration getFileNames()파일의 name들을 열거체로 반환 String getFilesystemName(String name)실제 업로드된 파일 이름(저장된 이름) String getOriginalFileName(String name)원본 파일 이름 String getContentType(String name)업로드된 파일의 형식(ContentType, MIME)","categories":[{"name":"Programing","slug":"Programing","permalink":"http://yoursite.com/categories/Programing/"},{"name":"Web","slug":"Programing/Web","permalink":"http://yoursite.com/categories/Programing/Web/"}],"tags":[]},{"title":"파일 업로드 (Commons-fileupload Lib활용)","slug":"fileupload-01","date":"2018-09-28T06:55:38.000Z","updated":"2018-10-01T13:30:47.909Z","comments":true,"path":"2018/09/28/fileupload-01/","link":"","permalink":"http://yoursite.com/2018/09/28/fileupload-01/","excerpt":"","text":"VIEW input 태그의 type을 file로 지정해주면 파일 업로드용 버튼으로 자동 생성된다. enctype 꼭 변경해주기! fileUpload.jsp12345678910111213141516171819202122232425&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!-- 파일 업로드 폼 --&gt;&lt;!-- (기본) enctype=\"application/x-www-form-urlencoded\" --&gt;&lt;!-- (변경) enctype=\"multipart/form-data\" --&gt;&lt;!-- enctype을 바꾸지않으면 파일명만 전달된다. (form-data로 변경하면 파일 내용까지 전달) --&gt;&lt;form action=\"/file/upload\" method=\"post\" enctype=\"multipart/form-data\"&gt;&lt;label&gt;제목: &lt;input type=\"text\" name=\"title\"&gt;&lt;/label&gt;&lt;br&gt;&lt;label&gt;첨부: &lt;input type=\"file\" name=\"uploadFile\"&gt;&lt;/label&gt;&lt;br&gt;&lt;button type=\"submit\"&gt;업로드&lt;/button&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; SERVLETFileUploadServlet.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179package file;import java.io.File;import java.io.IOException;import java.io.PrintWriter;import java.util.Iterator;import java.util.List;import java.util.UUID;import javax.servlet.ServletContext;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import org.apache.commons.fileupload.FileItem;import org.apache.commons.fileupload.FileUploadException;import org.apache.commons.fileupload.disk.DiskFileItemFactory;import org.apache.commons.fileupload.servlet.ServletFileUpload;@WebServlet(\"/file/upload\")public class FileUploadServlet extends HttpServlet &#123; private static final long serialVersionUID = 1L; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; // 파일 업로드 form 띄우기 req.getRequestDispatcher(\"/file/fileUpload.jsp\").forward(req, resp); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; // 파일 업로드 처리 // 요청 파라미터 한글 인코딩 설정 : UTF-8 req.setCharacterEncoding(\"UTF-8\"); // 응답 객체 MINE타입(Content-Type) 설정 resp.setContentType(\"text/html;charset=UTF-8\"); // 응답 객체 출력 스트림 PrintWriter out = resp.getWriter(); // ------ 파일 업로드 처리 시작 ------- // 1. 파일 업로드 형태가 맞는지 확인 // enctype이 multipart/form-data 인지 확인 boolean isMultipart = ServletFileUpload.isMultipartContent(req); // 1-1. multipart/form-data가 아닐 경우 처리 if(!isMultipart) &#123; out.println(\"&lt;h1&gt;enctype이 multipart/form-data가 아님&lt;/h1&gt;\"); return; &#125; // 1-2. multipart/form-data 로 요청이 이뤄졌을 경우 // 파일이 전송된 것으로 판단한다 // 2. 업로드된 파일을 처리하는 아이템팩토리 객체 생성 // DiskFileItemFactory : 디스크 기반의파일 아이템을 처리하는 API // 업로드 파일을 디스크에 임시 저장하고 후처리한다 DiskFileItemFactory factory = new DiskFileItemFactory(); // 3. 업로드아이템(파일)의 용량이 정당히 작으면 메모리로 처리 (1MB 이하) int maxMem = 1 * 1024 * 1024; // 1MB factory.setSizeThreshold(maxMem); // 4. 용량이 적당히 크면 임시파일 만들어서 처리 - 디스크 (1~10MB) ServletContext context = getServletContext(); File repository = new File(context.getRealPath(\"tmp\")); factory.setRepository(repository); // 5. 업로드 허용기준을 넘지 않으면 파일 업로드 처리 int maxFile = 10 * 1024 * 1024; // 10MB // 업로드 객체 생성 ServletFileUpload upload = new ServletFileUpload(factory); // 용량 제한 설정 : 10MB upload.setFileSizeMax(maxFile); // ----- 업로드 준비 완료 // 6. 업로드 데이터 파싱(추출) - 임시파일 업로드 수행 List&lt;FileItem&gt; items = null; try &#123; items = upload.parseRequest(req); &#125; catch (FileUploadException e) &#123; e.printStackTrace(); &#125; // 7. 파싱된 데이터 처리 Iterator&lt;FileItem&gt; iter = items.iterator(); // 요청정보 전부 처리하기 while(iter.hasNext()) &#123; FileItem item = iter.next(); // 요청정보 하나씩 얻기 //** 3가지 형태의 요청정보를 처리한다 // 1. 빈 파일 // 2. form-data(일반적인 요청파라미터) // 3. 파일 // 빈 파일 처리 if(item.getSize()&lt;=0) continue; // 빈 파일이 아닌 경우 if(item.isFormField()) &#123; // form-data 일 경우 // 키:값 쌍으로 전달된 요청 파리미터 // getFieldName() : 키 // getString() : 값 out.println(\"폼 필드 키 : \" + item.getFieldName()); out.println(\"값 : \" + item.getString()); // 활용 ex) if(\"title\".equals(item.getFieldName())) &#123; String data = item.getString(); // 데이터 처리 &#125; &#125; else &#123; // 파일일 경우 // 웹서버 로컬디스크에 저장 // (다른방법으로는 DB에 저장할 수 있다) // ---- UUID 생성 ---- UUID uuid = UUID.randomUUID();// System.out.println(uuid); String u = uuid.toString().split(\"-\")[4];// System.out.println(u); // ------------------ // 로컬 저장소 파일 File up = new File(context.getRealPath(\"upload\"), item.getName() + \"_\" + u); // ---- 업로드 기록 DB에 저장하기 ---- // 업로드 파일의 PK (fileno) // 연결된 테이블의 FK ( boardno, userid 등) // 업로드 파일의 원본 이름 // getString() // 업로드 파일의 저장 이름 // 코드로 바꾼 이름 (uuid 추가된 이름) // 업로드한 사람 (userid) // 업로드한 시간 (생략 가능) // 업로드 파일 크기 (생략 가능) // ex) // boardno fileno storedName originName // 454 67 image.jpg image.jpg_e2143f // ---------------------------- try &#123; // 실제 업로드 item.write(up); // 임시 파일 삭제 item.delete(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125;","categories":[{"name":"Programing","slug":"Programing","permalink":"http://yoursite.com/categories/Programing/"},{"name":"Web","slug":"Programing/Web","permalink":"http://yoursite.com/categories/Programing/Web/"}],"tags":[]},{"title":"파일 업로드를 위한 2가지 라이브러리 & 환경 세팅","slug":"fileupload-00","date":"2018-09-28T06:50:56.000Z","updated":"2018-10-01T13:29:33.557Z","comments":true,"path":"2018/09/28/fileupload-00/","link":"","permalink":"http://yoursite.com/2018/09/28/fileupload-00/","excerpt":"","text":"파일 업로드 라이브러리를 활용하는 2가지 방법이 있다.COS라이브러리가 사용엔 더 간편하지만, commons 라이브러리가 더 범용적으로 쓰인다고 한다. 1. commons-fileupload 라이브러리 + Commons-io 라이브러리(같이 필요) [commons-fileupload 다운방법] www.apache.org 접속 상단 메뉴 Projects 클릭 Commons 링크 찾아서 클릭 Fileupload 링크 찾아서 클릭 왼쪽 메뉴 Download 클릭 Binaries에서 .zip 다운 압축 해제 commons-fileupload-1.3.3.jar 사용 [Commons-io 다운방법] io 링크 찾아서 클릭 왼쪽 메뉴 Download 클릭 Binaries에서 .zip 다운 압축 해제 commons-io-2.6.jar 사용 2. COS 라이브러리 www.servlets.com 접속 왼쪽 메뉴에서 com.oreilly.servlet 클릭 Download 섹션에서cos-26Dec2008.zip 다운로드 압축 파일 내 lib폴더의 cos.jar 사용 보통 라이브러리를 다운 받을 때 bin/ src 형식이 있다. src는 실제 java 파일이 들어있고, 프로젝트에 추가하여 컴파일할 수 있고 커스텀마이징이 가능하다.bin 형식 안에는 jar 압축파일로 라이브러리가 제공된다. jar 형식의 라이브러리: java 코드를 모두 컴파일해서 바이트 코드로 변경된 것들이 모여져 있음 = 실행가능한 파일 [라이브러리 사용]jar 파일을 ‘WebContent - WEB-INF - lib’ 폴더 안에 넣어주면자동으로 ‘Java Resorces - Libraries - Web App Libraries’ 폴더안에 추가된다. 만약 자동으로 추가가 안된다면, ‘프로젝트 우클릭 - Build Path - Configure Build Path.. - Libraries탭 - Add External JARs…’ 버튼을 눌러서 직접 추가해준다.","categories":[{"name":"Programing","slug":"Programing","permalink":"http://yoursite.com/categories/Programing/"},{"name":"Web","slug":"Programing/Web","permalink":"http://yoursite.com/categories/Programing/Web/"}],"tags":[]},{"title":"HTTP Protocol","slug":"http-Protocol","date":"2018-09-28T01:29:06.000Z","updated":"2018-09-28T06:56:16.566Z","comments":true,"path":"2018/09/28/http-Protocol/","link":"","permalink":"http://yoursite.com/2018/09/28/http-Protocol/","excerpt":"","text":"1. Request 메시지 // —요청 헤드 요청 라인(스타트 라인)메소드(GET, POST)URLHTTP 버전(HTTP/1.0, HTTP/1.1(우리는 이 버전을 쓴다)) 요청 헤더 : 키-값 쌍으로 들어감Accept : 클라이언트가 받아들일 수 있는 형태Cookie : 쿠키정보Content-Type : 메시지 바디 타입Content-Length : 메시지 바디 타입Connection : 연결정보 // —요청 바디 요청 바디(엔티티 Entity, 페이로드 Payload)요청 파라미터(쿼리스트링) 2. Response 메시지 // —응답 헤드 응답 라인 (스타트 라인)HTTP버전상태코드 : 200, 404, 405, 500, 403상태 메시지 : HTTP/1.1 200 OK, HTTP/1.1 404 Not Found 응답 헤어Content-Type : 바디 내용의 데이터 형식, text/htmlContent-Length : 바디 내용의 길이Set-Cookie : 쿠키 설정 // —응답 바디 응답 바디응답 정보(주로 HTML)","categories":[{"name":"Programing","slug":"Programing","permalink":"http://yoursite.com/categories/Programing/"},{"name":"Web","slug":"Programing/Web","permalink":"http://yoursite.com/categories/Programing/Web/"}],"tags":[]},{"title":"페이징 처리","slug":"paging","date":"2018-09-27T14:14:30.000Z","updated":"2018-10-01T14:30:11.220Z","comments":true,"path":"2018/09/27/paging/","link":"","permalink":"http://yoursite.com/2018/09/27/paging/","excerpt":"","text":"Paging 활용 Paging객체 안의 페이징관련 변수들을 통해 DB에서 조회 범위를 설정해준다.-&gt; 설정된 범위까지만 조회해서 View에 넘겨줌 View에서 Pagination(맨 아래에 페이지번호,이동화살표 표시해주는 것)을 구현할 때 사용한다. Controller12345678910111213141516171819202122232425262728package controller.board;@WebServlet(\"/board/paginglist\")public class BoardPagingListController extends HttpServlet &#123; private static final long serialVersionUID = 1L; BoardService bservice = new BoardServiceImpl(); @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; // 현재 페이지 번호 얻기 int curPage = bservice.getCurPage(req); // 페이징 객체 int totalCount = bservice.getTotalCount(); Paging paging = new Paging(totalCount, curPage); // 게시글 목록 얻기 List&lt;Board&gt; boardList = bservice.getPagingList(paging); // 게시글목록 MODEL로 추가 req.setAttribute(\"boardList\", boardList); // 페이징 객체 MODEL로 추가 req.setAttribute(\"paging\", paging); // VIEW 지정 req.getRequestDispatcher(\"/view/board/list.jsp\").forward(req, resp); &#125;&#125; Paging.java util 폴더에 넣어서 관리123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102package util;public class Paging &#123; private int curPage; //현재 페이지 번호 (현재 선택한 페이지) private int totalCount; //총 게시글 수 (DB 조회 결과로 얻어옴) private int listCount; //한 페이지당 출력될 게시글 수 (직접 설정함) private int totalPage; //총 페이지 수 (계산으로 알아냄) private int pageCount; //한 화면에 출력될 페이지 수 (직접 설정함) private int startPage; //화면에 보이는 시작 페이지 (계산으로 알아냄) private int endPage; //화면에 보이는 끝 페이지 (계산으로 알아냄) private int startNo; //게시물리스트 첫 번호 private int endNo; //게시물리스트 마지막 번호 // 총 게시글 수만 입력하는 생성자 // curPage == 1 // pageCount == 10 // listCount == 10 public Paging(int totalCount) &#123; this.setTotalCount(totalCount); makePaging(); &#125; // 총 게시글 수와 현재 페이지를 입력하는 생성자 // pageCount == 10 // listCount == 10 public Paging(int totalCount, int curPage) &#123; this.setTotalCount(totalCount); this.setCurPage(curPage); makePaging(); &#125; // 총 게시글 수와 현재 페이지, 보여지는 게시글 수를 입력하는 생성자 // pageCount == 10 public Paging(int totalCount, int curPage, int listCount) &#123; this.setTotalCount(totalCount); this.setCurPage(curPage); this.setListCount(listCount); makePaging(); &#125; // 총 게시글 수와 현재 페이지, 보여지는 게시글 수, 페이지 수를 입력하는 생성자 public Paging(int totalCount, int curPage, int listCount, int pageCount) &#123; this.setTotalCount(totalCount); this.setCurPage(curPage); this.setListCount(listCount); this.setPageCount(pageCount); makePaging(); &#125; // 페이징 정보 생성 private void makePaging() &#123; if(totalCount == 0) return; //게시글이 없는 경우 // 기본값 설정 if(curPage == 0) setCurPage(1); //기본값으로 첫 페이지(1) 세팅 if(pageCount == 0) setPageCount(10); //한 화면에 보이는 페이지수 기본값(10) 세팅 if(listCount == 0) setListCount(10); //한 화면에 보이는 게시글수 기본값(10) 세팅 // 총 페이지수 계산 totalPage = totalCount / listCount; if( totalCount % listCount &gt; 0 ) totalPage++; // 현재 페이지가 총 페이지보다 크게 입력되면 // 강제로 마지막페이지 고정 if (totalPage &lt; curPage) curPage = totalPage; // 화면에 보일 시작 페이지 &amp; 끝 페이지 설정 // pageCount 단위로 끊어서 표시// startPage = ((curPage-1)/pageCount)*pageCount+1;// endPage = startPage+pageCount-1; // 화면에 보일 시작 페이지 &amp; 끝 페이지 설정 // 앞에 5개, 뒤에 4개 보이도록(현재 페이지 중앙 정렬) 표시 startPage = curPage -5; endPage = curPage + 4; if(startPage &lt;= 0) &#123; startPage = 1; endPage = pageCount; &#125; // 계산된 마지막 페이지가 totalPage보다 커질 경우 // 강제로 최종 페이지까지만 보이도록 설정 if(endPage &gt; totalPage) endPage = totalPage; // 게시글 시작번호 startNo = (curPage-1)*listCount+1; // 게시글 끝번호 endNo = curPage*listCount; &#125;// getter/setter 구현// toString() 구현&#125; Service123456789101112131415161718192021222324252627282930313233343536package service;import util.Paging;public class BoardServiceImpl implements BoardService&#123; BoardDao bDao = new BoardDaoImpl(); // 게시글 페이징 조회 @Override public List&lt;Board&gt; getPagingList(Paging paging) &#123; return bDao.selectPagingList(paging); &#125; // 요청파라미터에서 curPage 반환 @Override public int getCurPage(HttpServletRequest req) &#123; //요청 파라미터 받기 String curPage = req.getParameter(\"curPage\"); // null이나 \"\"이 아니면 int로 리턴 if(curPage !=null &amp;&amp; !\"\".equals(curPage)) &#123; return Integer.parseInt(curPage); &#125; //null이나 \"\"면 0으로 반환 return 0; &#125; // 전체 게시글 수 조회 @Override public int getTotalCount() &#123; return bDao.selectCntAll(); &#125;&#125; Viewlist.jsp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;div class=\"container\"&gt;&lt;h2 style=\"float: left;\"&gt; 게시판 목록&lt;/h2&gt;&lt;table class=\"table table-striped\"&gt;&lt;thead&gt;&lt;tr&gt; &lt;th style=\"width: 10%\"&gt;게시판 번호&lt;/th&gt; &lt;th style=\"width: 40%\"&gt;게시판 제목&lt;/th&gt; &lt;th style=\"width: 20%\"&gt;작성자&lt;/th&gt; &lt;th style=\"width: 10%\"&gt;조회수&lt;/th&gt; &lt;th style=\"width: 20%\"&gt;작성일&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;c:forEach var=\"board\" items=\"$&#123;boardList &#125;\"&gt;&lt;tr&gt; &lt;td&gt;$&#123;board.boardno&#125; &lt;/td&gt; &lt;td&gt;&lt;a href=\"/board/view?boardno=$&#123;board.boardno&#125;&amp;curPage=$&#123;paging.curPage&#125;\"&gt;$&#123;board.title&#125;&lt;/a&gt;&lt;/td&gt; &lt;td&gt;$&#123;board.writer&#125; &lt;/td&gt; &lt;td&gt;$&#123;board.hit&#125; &lt;/td&gt; &lt;td&gt;$&#123;board.writtendate&#125; &lt;/td&gt;&lt;/tr&gt;&lt;/c:forEach&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;div class=\"text-center\"&gt; &lt;ul class=\"pagination\"&gt; &lt;!-- 처음으로 가기 --&gt; &lt;c:if test=\"$&#123;paging.curPage ne 1 &#125;\"&gt; &lt;li&gt; &lt;a href=\"/board/paginglist\" aria-label=\"Previous\"&gt; &lt;span aria-hidden=\"true\"&gt;처음&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;/c:if&gt; &lt;!-- 이전 페이지 --&gt; &lt;!-- 첫 페이지라면 버튼 동작 안되게 만들기 --&gt; &lt;c:if test=\"$&#123;paging.curPage eq 1 &#125;\"&gt; &lt;li class=\"disabled\"&gt; &lt;span aria-hidden=\"true\"&gt;&amp;laquo;&lt;/span&gt; &lt;/li&gt; &lt;/c:if&gt; &lt;c:if test=\"$&#123;paging.curPage ne 1 &#125;\"&gt; &lt;li&gt; &lt;a href=\"/board/paginglist?curPage=$&#123;paging.curPage-1 &#125;\" aria-label=\"Previous\"&gt; &lt;span aria-hidden=\"true\"&gt;&amp;laquo;&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;/c:if&gt; &lt;!-- 페이징 리스트 --&gt; &lt;c:forEach var=\"i\" begin=\"$&#123;paging.startPage &#125;\" end=\"$&#123;paging.endPage &#125;\" step=\"1\"&gt; &lt;!-- 현재 보고 있는 페이지 번호만 강조하기 --&gt; &lt;c:if test=\"$&#123;paging.curPage eq i&#125;\"&gt; &lt;li class=\"active\"&gt;&lt;a href=\"/board/paginglist?curPage=$&#123;i &#125;\"&gt;$&#123;i &#125;&lt;/a&gt;&lt;/li&gt; &lt;/c:if&gt; &lt;c:if test=\"$&#123;paging.curPage ne i&#125;\"&gt; &lt;li&gt;&lt;a href=\"/board/paginglist?curPage=$&#123;i &#125;\"&gt;$&#123;i &#125;&lt;/a&gt;&lt;/li&gt; &lt;/c:if&gt; &lt;/c:forEach&gt; &lt;!-- 다음 페이지 --&gt; &lt;c:if test=\"$&#123;paging.curPage eq paging.totalPage&#125;\"&gt; &lt;li class=\"disabled\"&gt; &lt;span aria-hidden=\"true\"&gt;&amp;raquo;&lt;/span&gt; &lt;/li&gt; &lt;/c:if&gt; &lt;c:if test=\"$&#123;paging.curPage ne paging.totalPage&#125;\"&gt; &lt;li&gt; &lt;a href=\"/board/paginglist?curPage=$&#123;paging.curPage+1 &#125;\" aria-label=\"Next\"&gt; &lt;span aria-hidden=\"true\"&gt;&amp;raquo;&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;/c:if&gt; &lt;/ul&gt;&lt;/div&gt;&lt;/div&gt;","categories":[{"name":"Programing","slug":"Programing","permalink":"http://yoursite.com/categories/Programing/"},{"name":"Web","slug":"Programing/Web","permalink":"http://yoursite.com/categories/Programing/Web/"}],"tags":[]},{"title":"JDBC 사전 준비","slug":"ready-jdbc","date":"2018-09-19T06:46:12.000Z","updated":"2018-09-19T06:49:23.723Z","comments":true,"path":"2018/09/19/ready-jdbc/","link":"","permalink":"http://yoursite.com/2018/09/19/ready-jdbc/","excerpt":"","text":"JDBC를 이용한 프로젝트 개발 시 사전준비 할 것 ojdbc6.jar -&gt; ‘WebContent - WEB-INF - lib’ 폴더로 복사 DBConn.java 파일(DB 객체 싱글톤으로 이용할 수 있게 이전에 만들어 놓은 파일) -&gt; ‘Java Resource - src - dbutil’ 폴더로 복사(DB 객체 생성 파트는 항상 똑같아서 그냥 복붙해서 쓰려고..)","categories":[{"name":"Programing","slug":"Programing","permalink":"http://yoursite.com/categories/Programing/"},{"name":"JDBC","slug":"Programing/JDBC","permalink":"http://yoursite.com/categories/Programing/JDBC/"}],"tags":[]},{"title":"자바빈","slug":"javabean","date":"2018-09-14T07:57:11.000Z","updated":"2018-09-19T07:58:52.760Z","comments":true,"path":"2018/09/14/javabean/","link":"","permalink":"http://yoursite.com/2018/09/14/javabean/","excerpt":"","text":"자바 빈, Java Bean 자바 클래스 프로그램에서 사용할 정보를 모아놓은 데이터 저장소 DTO 로 사용됨 자바빈 설계 원칙(규칙) 로직 X 기능을 담은 메소드를 구현하지 않는다 디폴트 패키지를 사용하지 않는다( 패키지가 반드시 있어야한다) public 클래스로 생성한다 멤버필드는 private으로 지정한다 생성자는 디폴트 생성자만 허용한다(만들지 않는 게 좋다) getter, setter 를 구현한다 getter, setter는 public 접근제한자를 가진다 getter의 반환타입이 boolean이면 get대신 is를 쓸 수 있다 시스템에 등록된 자바빈의 멤버변수는 Property(프로퍼티)라고 부른다 POJO, Plain Old Java Object 어플리케이션의 규모가 커지면서 캡슐화된 클래스의 규모도 너무 커지게 되자 나온 개념 개발자가 마음대로 정의할 수 있는 객체(extends 나 implements를 하지않고 Object만 부모로 가지는 객체) 가볍고, 유연하고, 간단한 객체 그냥 일반 클래스,,,이걸 적용한게 DTO,,,","categories":[{"name":"Programing","slug":"Programing","permalink":"http://yoursite.com/categories/Programing/"},{"name":"Web","slug":"Programing/Web","permalink":"http://yoursite.com/categories/Programing/Web/"}],"tags":[]},{"title":"JSP 내장 객체 종류 & 유효범위","slug":"jsp-implict-object","date":"2018-09-13T07:10:45.000Z","updated":"2018-10-01T14:13:31.037Z","comments":true,"path":"2018/09/13/jsp-implict-object/","link":"","permalink":"http://yoursite.com/2018/09/13/jsp-implict-object/","excerpt":"","text":"JSP 내장 객체 JSP페이지에서 객체 생성 없이 바로 사용할 수 있는 객체들 서블릿 컨테이너에 의해 JSP-&gt;Servlet으로 변환될 때 자동 생성됨 내장 객체의 종류 입출력(요청,응답) 관련 객체– request : HTTP요청 객체– response : HTTP응답 객체– out : 응답 객체 출력 스트림 서블릿 관련 객체– page : 서블릿으로 변환된 페이지 객체(서블릿으로 변환된 JSP 자기 자신)– config : 서블릿 설정 정보를 저장하고 있는 객체 정보 전달 객체– pageContext : Page Scope에 들어있는 컨텍스트 정보– request : Request Scope에 들어있는 컨텍스트 정보– session : Session Scope에 들어있는 컨텍스트 정보– application : Application Scope에 들어있는 컨텍스트 정보 예외 처리 관련 객체– exception : page지시자의 isErrorPage속성을 true로 설정하면 사용할 수 있는 객체, 예외정보를 가진다 내장객체의 유효범위(Scope) page : 하나의 JSP페이지를 처리하는 동안 유지 (pageContext 객체를 사용) request : 하나의 요청(HTTP Request)를 처리하는 동안 유지 (MODEL2 환경의 Controller - VIEW 로 이어지는 동안 유지) (ex.Controller - setAttribute -&gt; VIEW: getAttribute 로 이용가능한 이유) session : 연결된 하나의 브라우저에게 서비스하는 동안 유지 (페이지를 이동해도 유지됨) (브라우저끼리는 별개로 유지) application : 동일한 웹어플리케이션이 구동되는 동안 유지 (서버가 켜지고 꺼질 때까지 유지됨) ** 컨텍스트 정보 저장 : setAttribute(“변수명”, 값)** 컨텍스트 정보 읽기 : getAttribute(“변수명”) ex)1234567891011121314151617181920212223// -----------------------------// requestrequest.setAttribute(&quot;name&quot;, name);request.getAttribute(&quot;name&quot;);// -----------------------------// sessionsession.setAttribute(&quot;loginState&quot;, true);if( (boolean)session.getAttribute(&quot;loginState&quot;) )&#123; // 로그인 상태 out.write(&quot;환영합니다&quot;);&#125; else &#123; // 비로그인 상태 out.write(&quot;로그인이 필요합니다&quot;);&#125;// -----------------------------// pagepageContext.setAttribute(&quot;data&quot;, &quot;hi&quot;);// -----------------------------// applicationapplication.setAttribute(&quot;info&quot;, info); *** 위의 내용들은 JSP 문법 내에서 쓰이는 이름이다. 서블릿 내에서 사용할 때는 달라질 수 있다.","categories":[{"name":"Programing","slug":"Programing","permalink":"http://yoursite.com/categories/Programing/"},{"name":"JSP","slug":"Programing/JSP","permalink":"http://yoursite.com/categories/Programing/JSP/"}],"tags":[]},{"title":"MVC예제 - 간단한 회원가입","slug":"servletEx-member","date":"2018-09-12T12:27:38.000Z","updated":"2018-10-01T14:06:59.665Z","comments":true,"path":"2018/09/12/servletEx-member/","link":"","permalink":"http://yoursite.com/2018/09/12/servletEx-member/","excerpt":"","text":"MVC 패턴을 이용한 간단한 회원가입 기능을 구현해보고자 한다. 아래는 프로젝트 구조이다.이번에는 service를 추가해서 구현하였다. (이전 버전은 블로그에 정리해두지 않았다) Service 단이 해주는 역할: Service는 Controller의 역할 중 일부를 담당하는 객체임 Service는 Controller의 비지니스로직을 담당하는 계층 Service는 Controller의 데이터를 적절히 가공해주는 역할 Service는 DAO를 통해 얻은 데이터를 추가적으로 가공하여 Controller에 제공 DAO는 데이터베이스의 데이터를 추가적인 가공없이 사용함 (단지 DB와 관련된 쿼리문 수행만 하게 해준다) 브라우저 -&gt; Controller -&gt; Service -&gt; DAO -&gt; 데이터베이스-&gt; DAO -&gt; Service -&gt; Controller -&gt; 브라우저 순으로 처리됨 [구조] Controller: MemberController.java - Servlet Class DAO: MemberDao.java - Interface: MemberDaoImpl.java - Class DBUtil: DBConn.java - Class DTO: Member.java - Class Service: MemberService - Interface: MemberServiceImpl - Class VIEW: joinForm.jsp - JSP: result.jsp - JSP CONTROLLERMemberController.java123456789101112131415161718192021222324252627282930313233package controller;@WebServlet(\"/member/join\")public class MemberController extends HttpServlet &#123; private static final long serialVersionUID = 1L; private MemberService memberService = new MemberServiceImpl(); @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; // VIEW 지정 req.getRequestDispatcher(\"/view/member/joinForm.jsp\").forward(req, resp); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; // 요청파라미터 한글 처리 인코딩 설정 (UTF-8) req.setCharacterEncoding(\"utf-8\"); // Service를 통한 요청파라미터처리 Member mem = memberService.getMemberParameter(req, resp); // Service를 통한 회원가입(데이터베이스 삽입) boolean joinResult = memberService.join(mem); // join결과 request에 담기 // VIEW에 전달할 MODEL값을 담기 req.setAttribute(\"joinResult\", joinResult); // VIEW 지정하기 req.getRequestDispatcher(\"/view/member/result.jsp\").forward(req, resp); &#125;&#125; SERVICEMemberDaoImpl.java123456789101112131415161718192021222324252627282930313233343536373839404142package service;public class MemberServiceImpl implements MemberService &#123; private MemberDao memberDao = new MemberDaoImpl(); @Override public Member getMemberParameter(HttpServletRequest req, HttpServletResponse resp) &#123; // 요청파라미터 받기 String userid = (String) req.getParameter(\"userid\"); String nick = (String) req.getParameter(\"nick\"); String email = (String) req.getParameter(\"email\"); // DTO에 요청파라미터 담기 Member mem = new Member(); mem.setUserid(userid); mem.setNick(nick); mem.setEmail(email); return mem; &#125; @Override public boolean join(Member mem) &#123; //기존에 존재하는 아이디 인지 확인하고 회원가입 처리 if( memberDao.selectCntMember(mem) &gt; 0 ) &#123; return false; //기존에 존재함, 회원가입 실패 &#125; //회원가입(데이터베이스 삽입) memberDao.insertMember(mem); //회원가입 성공 여부 판단 if( memberDao.selectCntMember(mem) &gt; 0 ) &#123; return true; //회원가입 성공 &#125; else &#123; return false; //회원가입 실패 &#125; &#125;&#125; DAOMemberDaoImpl.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package dao;public class MemberDaoImpl implements MemberDao &#123; private Connection conn = DBConn.getConnection(); private PreparedStatement ps = null; private ResultSet rs = null; @Override public int selectCntMember(Member mem) &#123; //회원 조회 쿼리 String countSql = \"\"; countSql+=\"SELECT COUNT(*) FROM member\"; countSql+=\" WHERE userid=?\"; int cnt = 0; try &#123; ps = conn.prepareStatement(countSql); //조회할 ID 지정 ps.setString(1, mem.getUserid()); //SELECT 수행 rs = ps.executeQuery(); //SELECT 결과 처리 rs.next(); cnt = rs.getInt(1); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; if(ps!=null) ps.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; return cnt; &#125; @Override public void insertMember(Member mem) &#123; //회원가입 쿼리 String sql = \"\"; sql+=\"INSERT INTO member ( userid, nick, email )\"; sql+=\" VALUES ( ?, ?, ? )\"; try &#123; ps = conn.prepareStatement(sql); //삽입할 내용 지정 ps.setString(1, mem.getUserid()); ps.setString(2, mem.getNick()); ps.setString(3, mem.getEmail()); // INSERT 쿼리 수행 ps.executeUpdate(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125;&#125;","categories":[{"name":"Programing","slug":"Programing","permalink":"http://yoursite.com/categories/Programing/"},{"name":"Web","slug":"Programing/Web","permalink":"http://yoursite.com/categories/Programing/Web/"}],"tags":[]},{"title":"JSP 기본 태그","slug":"jsp-basic-tag","date":"2018-09-12T06:51:51.000Z","updated":"2018-09-28T03:20:51.831Z","comments":true,"path":"2018/09/12/jsp-basic-tag/","link":"","permalink":"http://yoursite.com/2018/09/12/jsp-basic-tag/","excerpt":"","text":"JSP 문법 HTML문서 양식에 Java코드를 삽입하는 형식 Servlet컨테이너(WAS)에 의해 Servlet코드로 변경된다 * Servlet 코드로 변경되어 저장되는 위치: 프로젝트위치\\.metadata\\.plugins\\org.eclipse.wst.server.core \\tmp0\\work\\Catalina\\localhost\\ \\ 프로젝트명\\org\\apache\\jsp JSP 기본 태그 스크립트릿(Scriptlet) &lt;%&nbsp;&nbsp;&nbsp;%&gt; 선언(Declaration) &lt;%!&nbsp;&nbsp;%&gt; 표현식(Expression) &lt;%=&nbsp;&nbsp;%&gt; 지시자(Directive) &lt;%@&nbsp;&nbsp;%&gt; 주석(comment) &lt;%--&nbsp;&nbsp;--%&gt; 스크립트릿(Scriptlet), &lt;%&nbsp;&nbsp;&nbsp;%&gt; JSP에서 자바코드를 작성하기위해 지정하는 영역 수행코드를 위주로 작성한다 (제어문, 메소드호출, 연산 등등) _jspService() 메소드 내에 변환되어 작성된다 선언(Declaration), &lt;%!&nbsp;&nbsp;%&gt; JSP페이지에서 사용할 변수, 메소드를 정의할 때 사용하는 영역 JSP를 변환한 서블릿클래스의 클래스 영역에 정의된다 멤버필드, 멤버메소드로 만들어진다 변수 선언코드, 메소드 정의코드만 작성하도록 한다 표현식(Expression), &lt;%=&nbsp;&nbsp;%&gt; HTML문서에 포함될 내용을 간단히 작성하기 위한 영역 자바데이터를 HTML문서에 간단히 출력할 수 있다 서블릿 컨테이너에 의해 out.print() 코드로 변환된다 ; 을 넣지 않는다 지시자(Directive), &lt;%@&nbsp;&nbsp;%&gt; Servlet/JSP컨테이너에 메시지를 보내기위한 영역 JSP가 실행될 때 지시자의 내용을 읽어서 JSP페이지 설정에사용할 수 있도록 설정내용을 추가하는 태그 페이지의 특수 정보나 설정들을 처리 JSP-&gt;Servlet으로 변환할 때 필요한 정보를 기술한다 브라우저에서 확인되지 않는다 주석(Comment), &lt;%--&nbsp;&nbsp;--%&gt; HTML 주석&nbsp;&nbsp; &lt;!-- HTML주석 --&gt;웹브라우저가 해석하지 못하게 만든다 JS 주석 &nbsp;&nbsp; /*&nbsp; JS주석&nbsp; */ &nbsp;또는&nbsp; //JS주석&lt;script> 태그 내에서 사용브라우저의 JS엔진이 해석하지 못하게 만든다 CSS 주석 &nbsp;&nbsp; / CSS주석 \\/&lt;style> 태그 내에서 사용브라우저의 CSS엔진이 해석하지 못하게 만든다 JSP 주석 &lt;%-- JSP주석 --%&gt;서블릿 코드로 변환되지 않도록 막는다웹브라우저에 전송되지 않음 Java 주석 /* Java주석 */ &nbsp;또는&nbsp; //Java주석스크립트릿 태그 내에서 사용서블릿컨테이너가 코드를 수행하지 못하게 막는다웹브라우저에 전송되지 않음","categories":[{"name":"Programing","slug":"Programing","permalink":"http://yoursite.com/categories/Programing/"},{"name":"JSP","slug":"Programing/JSP","permalink":"http://yoursite.com/categories/Programing/JSP/"}],"tags":[]},{"title":"서블릿, Servlet","slug":"servlet","date":"2018-09-10T06:46:45.000Z","updated":"2018-09-19T07:53:27.344Z","comments":true,"path":"2018/09/10/servlet/","link":"","permalink":"http://yoursite.com/2018/09/10/servlet/","excerpt":"","text":"서블릿, Servlet Servlet = Server + Applet 서버에서 동작하는 Applet이라는 뜻 Applet : 자바에서 바이트 코드의 형태로 배포되는 실행가능 프로그램 웹 어플리케이션을 작성하는 기술 자바 일반클래스에 HttpServlet 클래스를 상속하면 서블릿 클래스라고 부른다(완성된 Applet파일을 업로드하면 톰캣이 실행시켜 준다 (시점: 브라우저에 접속한 순간)) -&gt; 줄여서 ‘서블릿’이라고 부른다 (javax.servlet.HttpServlet Class) 서블릿 클래스 형태1234import javax.servlet.http.HttpServlet;public class [서블릿클래스명] extends HttpServlet &#123; //클라이언트 요청 처리 코드 (doGet, doPost)&#125; 접근 제한자가 반드시 public doGet, doPost 메소드는 오버라이딩해서 작성한다 서블릿의 동작 원리클라이언트 요청 → (Apache 웹서버 - Tomcat WAS(JVM) ) → 서블릿 컨테이너 → 서블릿객체 → service() (멀티스레딩) → doGet() / doPost()→ 서블릿 컨네이너 → Apache- Tomcat 웹서버 → 클라이언트 응답 ** 요청되는 정보 : url + 메소드(get/post) + 요청파라미터(쿼리스트링 (url 뒤에 ?로 붙는 값들))** Tomcat에 있는 JVM이 서블릿객체를 컴파일(해석)해준다** WAS 가 서블릿 컨테이너에 어떤 요청이 왔는지 url 등 정보를 판단해서 서블릿 객체로 넘겨줌** 서블릿객체의 service() 가 요청된 정보를 받아서 get/post 를 판별하여 해당하는 메소드를 호출** service() 부터는 멀티스레딩 방식으로 각 각의 요청을 따로 처리해준다 ** /image.jpg 같은 것을 url 로 요청했을 때는 WAS-서블릿 컨테이너를 거치지 않고 Apache 웹서버가 바로 해당 파일을 읽어와준다. ** 서블릿 컨테이너 서블릿 처리환경을 구축하는 역할 서블릿을 실행시켜주는 역할 WAS 서버와 서블릿객체 사이의 중간다리 역할을 수행한다 요청 URL-Pattern 과 서블릿객체를 1:1 매핑해놓고 요청을 기다린다 (WAS 안에 들어있다.) (WAS 가 web.xml 을 보고 만들어 놓는다) 서블릿 객체 라이프 사이클(생명주기)객체 생성 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ init()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ service()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→destroy()(생성자호출) (서블릿초기화) (doGet(),doPost() 반복수행) : init() 까지 수행하고 기다리고 있다가 클라이언트에게 요청이 들어오면 service() (멀티스레딩 형식으로) 가 수행된다.모든 서블릿 객체가 위와 같은 사이클로 실행된다.** 웹서비스를 처음 실행하고 첫 클라이언트는 조금 느려진다. (서블릿마다 init() 작업까지 수행해줘야하기 때문에)","categories":[{"name":"Programing","slug":"Programing","permalink":"http://yoursite.com/categories/Programing/"},{"name":"JSP","slug":"Programing/JSP","permalink":"http://yoursite.com/categories/Programing/JSP/"}],"tags":[]},{"title":"프로그래밍 아키텍쳐/ MODEL 1,2 / MVC Pattern","slug":"programing-architecture","date":"2018-09-10T06:34:52.000Z","updated":"2018-09-19T07:52:42.594Z","comments":true,"path":"2018/09/10/programing-architecture/","link":"","permalink":"http://yoursite.com/2018/09/10/programing-architecture/","excerpt":"","text":"프로그래밍 아키텍쳐 프로그램 작성 구조(구성) MODEL 1 : 비지니스 로직과 프레젠테이션 로직을 합쳐놓은 것 MODEL 2 : 비지니스 로직과 프레젠테이션 로직을 분리시켜 놓은 것 비지니스 로직, Business Logic 클라이언트(사용자)에게 보이지 않는 부분 데이터를 처리하는 (가공하는) 응용프로그램의 일부 영역 주로 데이터베이스 처리 ex) 로그인 데이터 인증(데이터베이스 존재 여부 확인) Servlet으로 구현함 Server Side Script (Language) : Java(Servlet) 프레젠테이션 로직, Presentation Logic 클라이언트에게 보여지는 부분 표현될 화면을 구성하기 위한 응용프로그램의 일부 영역 JSP 로 구현 Client Side Script(Language) : HTML, CSS, JS MODEL 1,2 / MVC PatternMODEL 1 비지니스 로직 + 프레젠테이션 로직을 하나의 파일로 구현한 것 장점 – 작업(개발)이 쉽다 – 구조가 단순해서 직관적이다 – 중소형 프로젝트에 어울림 단점 – 코드가 섞여있어서 유지보수가 어렵다 – 프로젝트 적응력이 떨어진다 – 재사용성이 떨어진다 – 분업이 힘들다 – 대형 프로젝트에 어울리지 않는다 MODEL 2 비지니스 로직과 프레젠테이션 로직을 다른 파일로 분리한 형태 대형 프로젝트에 잘 어울리며 분업하기에 적절하다 단, MODEL 2 개발방식에 대한 이해가 필요하며 기본 지식의 요구수준이 높다 MVC 패턴 MODEL : 데이터, JavaBean Class (DTO Class) VIEW : 프레젠테이션 로직, JSP (HTML) CONTROLLER : 비지니스 로직, Servlet (요청파라미터처리, DAO) * DAO : DB접근 객체( 데이터베이스의 자료를 관리하는 객체)&nbsp;&nbsp;&nbsp;DTO : 모델이 되는 객체&nbsp;&nbsp;&nbsp;(** 테이블 하나 당 DAO 클래스 하나로 만들면 좋음)","categories":[{"name":"Programing","slug":"Programing","permalink":"http://yoursite.com/categories/Programing/"},{"name":"Web","slug":"Programing/Web","permalink":"http://yoursite.com/categories/Programing/Web/"}],"tags":[]},{"title":"jQuery 사용하기","slug":"jQuery-use","date":"2018-09-06T04:01:02.000Z","updated":"2018-09-19T07:12:01.647Z","comments":true,"path":"2018/09/06/jQuery-use/","link":"","permalink":"http://yoursite.com/2018/09/06/jQuery-use/","excerpt":"","text":"jQuery Core jQuery $ jQuery 문법이 적용되었음을 알리는 키워드 1234567 jQuery(document).ready(function() &#123; &#125;);//---------------------------------------- $(document).ready(function() &#123; &#125;); jQuery Core를 변수에 저장하여 사용할 수도 있다12345var J = jQuery;J(document).ready(function() &#123; J(&quot;div&quot;).css(&quot;color&quot;, &quot;blue&quot;);&#125;); jQuery 노드 객체 찾기 $(셀렉터) $(js객체) jQuery DOM객체로 노드를 반환한다 n번째 노드 접근하기 $(객체).eq(idx) : idx번째 노드를 jQuery DOM객체로 반환 $(객체).get(idx) : idx번째 노드를 JS DOM객체로 반환 123$(&quot;p&quot;).eq(2).css(&quot;color&quot;, &quot;red&quot;);//--------------------------------$(&quot;p&quot;).get(3).style.color = &quot;blue&quot;; 순차적으로 노드 접근하기 $(객체).each( function( idx, element ) {&nbsp;&nbsp;&nbsp;&nbsp;// 요소마다 각각 반복될 코드});idx : 객체의 인덱스element : 해당 반복의 JS 객체 ** 코드 내에서 this 키워드를 사용하면 반복되고있는 노드를 JS객체로 사용가능하다 ( == element 매개변수 ) ** jQuery 객체로 사용하고 싶다면 $(this) 를 사용한다 객체 비교하기 $(객체1).is( $(객체2) )객체1과 객체2가 같은 객체인지 비교 true - 같은 객체false - 다른 객체 하위노드중에서 특정 노드 찾기 $(객체).find( selector )객체의 하위 노드중에서 selector에 맞는 객체 반환 자식 노드 찾기 $(객체).children() $(객체).children( selector ) 부모 노드 찾기 $(객체).parent() $(객체).parent( selector ) 조상 노드 찾기 $(객체).parents() $(객체).parents( selector ) 이전 형제노드 찾기 $(객체).prev() $(객체).prev( selector ) 이전 모든 형제노드 찾기 $(객체).prevAll() $(객체).prevAll( selector ) 다음 형제노드 찾기 $(객체).next() $(객체).next( selector ) 다음 모든 형제노드 찾기 $(객체).nextAll() $(객체).nextAll( selector ) 노드 생성 $(“노드텍스트”)ex) $(“&lt;div>“) -&gt; &lt;div> 태그 생성 ** 주의&nbsp;&nbsp;&nbsp; $(“div”) - div태그 선택&nbsp;&nbsp;&nbsp; $(“&lt;div>“) - div태그 생성 $(객체).html(“노드텍스트”)ex) $(“div”).html(“&lt;p>안녕&lt;/p>“); 노드 복사 $(객체).clone() ex) var $div2 = $(“#myDiv”).clone(); 노드 추가/이동 $부모노드.append( $추가노드 ) $추가노드.appendTo( $부모노드 ) 부모노드의 마지막 자식으로 추가노드 삽입 추가되는 노드가 이미 DOM트리 구성요소면 이동처리됨 $부모노드.prepend( $추가노드 )$추가노드.preondTo( $부모노드 ): 부모노드의 첫 자식으로 추가노드 삽입/이동 $기준노드.before( $추가노드 )$추가노드.insertBefore( $기준노드 ): 기준노드의 이전형제로 추가노드를 삽입/이동 $기준노드.after( $추가노드 )$추가노드.insertAfter( $기준노드 ): 기준노드의 다음형제로 추가노드를 삽입/이동 노드 내용 읽기/변경 $객체.html() $객체.html(“태그를포함한텍스트”) $객체.text() $객체.text(“기본텍스트”)** 매개변수가 없는 함수는 읽기, 매개변수가 있는 함수는 변경하기** html함수는 태그형식을 유지하며 처리** text함수는 태그를 무시하고 단순텍스트로 처리 클래스 속성 다루기(추가/삭제) $(객체).addClass(“클래스명”) $(객체).removeClass(“클래스명”) $(객체).removeClass() // 전체 클래스 삭제 모든 속성 다루기 $(객체).attr(“속성이름”) : 속성값 가져오기 $(객체).attr(“속성이름”, “속성값”) : 속성값 지정하기 $(객체).attr({“속성명1” : “속성값1”, “속성명2” : “속성값2”,…}); : 여러 속성 지정하기 ** 여러 속성값을 불러오는 방법은 지원되지 않는다","categories":[{"name":"Programing","slug":"Programing","permalink":"http://yoursite.com/categories/Programing/"},{"name":"jQuery","slug":"Programing/jQuery","permalink":"http://yoursite.com/categories/Programing/jQuery/"}],"tags":[]},{"title":"jQuery","slug":"jQuery","date":"2018-09-06T03:58:55.000Z","updated":"2018-09-18T04:00:12.225Z","comments":true,"path":"2018/09/06/jQuery/","link":"","permalink":"http://yoursite.com/2018/09/06/jQuery/","excerpt":"","text":"jQuery? 자바스크립트의 DOM을 쉽게 사용하기위해 만들어진 라이브러리 순수 자바스크립트 코드보다 효율적이고, 코드생산성이 향상됨 HTML노드, 스타일, 속성, 이벤트 등을 다룰 수 있다 CSS 선택자를 이용한다 http://www.jquery.com/ jQuery 주요 기능 jQuery DOM : JS DOM객체를 다루는 기능 jQuery Event : JS Event를 다루는 기능 jQuery Ajax : 비동기통신(Ajax)를 다루는 기능 jQuery Effects : 효과(애니메이션, 모션 등) jQuery Plugin : 추가 기능(플러그인) jQuery 버전별 특징 1.x다양한 브라우저에 호환되는 버전최대한 많은 브라우저에 호환되는 게 목적브라우저 특징에 맞는 동작이 생략된 경우가 있음 2.x코드의 성능, 다양한 기능을 제공하기 위해 IE8이하는 지원X옛 코드를 버리고 경량화하고 성능을 개선함기능도 추가됨 3.x2.x의 업그레이드 버전jQuery Migrate는 1.x 업그레이드 버전","categories":[{"name":"Programing","slug":"Programing","permalink":"http://yoursite.com/categories/Programing/"},{"name":"jQuery","slug":"Programing/jQuery","permalink":"http://yoursite.com/categories/Programing/jQuery/"}],"tags":[]},{"title":"jQuery - CND를 이용해 파일 불러오기","slug":"cnd","date":"2018-09-06T03:53:38.000Z","updated":"2018-10-01T11:01:48.594Z","comments":true,"path":"2018/09/06/cnd/","link":"","permalink":"http://yoursite.com/2018/09/06/cnd/","excerpt":"","text":"CDN, Content Delivery Network jQuery 2.2.4 CDN 12&lt;script src=&quot;https://code.jquery.com/jquery-2.2.4.min.js&quot;&gt;&lt;/script&gt; jQuery를 사용하기 위해 HTML 소스코드에 위와 같은 태그를 삽입해주면 별로의 다운로드 없이 파일을 받아 사용할 수 있다. 콘텐츠(자료)를 효율적으로 전달하기 위해 준비된 네트워크 주로 10MB이상의 파일을 다루지만 요즘엔 크기에 상관없이 사용 클라이어트의 컨텐츠 요청 병목현상을 해결한다 서버의 불필요한 트래픽을 줄이고 반복작업을 줄여준다 자주 사용되는 컨텐츠(자료, 파일)을 네트워크 중간중간에 복사해두고 클라이언트 요청을 받으면 적절한 위치의 컨텐츠를 전송해준다","categories":[{"name":"Programing","slug":"Programing","permalink":"http://yoursite.com/categories/Programing/"},{"name":"jQuery","slug":"Programing/jQuery","permalink":"http://yoursite.com/categories/Programing/jQuery/"}],"tags":[]},{"title":"JS Event Listener 등록하는 방법","slug":"js-eventListener","date":"2018-09-05T11:44:39.000Z","updated":"2018-09-18T03:50:29.008Z","comments":true,"path":"2018/09/05/js-eventListener/","link":"","permalink":"http://yoursite.com/2018/09/05/js-eventListener/","excerpt":"","text":"JS Event Listener 등록하는(바인딩) 방법 1. HTML 태그의 인라인 방식1&lt;div onclick=&quot;alert(&apos;hi!&apos;)&quot;\\&gt;Hello&lt;/div\\&gt; 2. DOM을 이용한 바인딩 - Event Attribute사용1234var e = document.getElementById(&quot;btn&quot;);e.onclick = function()&#123; alert(&quot;HI&quot;);&#125;; 3. DOM을 이용한 바인딩 - addEventListener() 함수 사용1234var e = document.getElementById(&quot;btn&quot;);e.addEventListener(&quot;click&quot;, function()&#123; alert(&quot;Hello&quot;);&#125;); ※ JS 주요 이벤트 속성 onchange 요소가 변경될 때 onsubmit 폼이 제출될 때onreset 폼이 재설정될 때 onselect 값이 선택되었을 때 onfocus 포커스가 얻었을 때onblur 포커스를 잃었을 때 onkeydown 키를 눌렀을 때onkeypress 키를 눌렀다가 놓았을 때onkeyup 키를 놓았을 때 onclick 마우스를 클릭했을 때ondblclick 마우스를 더블클릭했을 때 onmousedown 마우스 버튼을 누르고 있을 때onmouseup 마우스를 놓았을 때 onmousemove 마우스 포인트를 이동했을 때 onmouseout 마우스 포인트가 요소의 바깥으로 이동했을 때onmouseover 마우스 포인트가 요소로 들어왔을 때","categories":[{"name":"Programing","slug":"Programing","permalink":"http://yoursite.com/categories/Programing/"},{"name":"Javascript","slug":"Programing/Javascript","permalink":"http://yoursite.com/categories/Programing/Javascript/"}],"tags":[]},{"title":"DOM 객체 함수 API","slug":"dom-api","date":"2018-09-05T08:23:04.000Z","updated":"2018-09-18T03:43:37.090Z","comments":true,"path":"2018/09/05/dom-api/","link":"","permalink":"http://yoursite.com/2018/09/05/dom-api/","excerpt":"","text":"Element 생성 document.createElement(“tagName”): 요소 노드 만들기 document.createTextNode(“text”): 텍스트 노드 만들기 Element 추가 객체.appendChild(대상) : 객체에 노드 연결(추가)하기 ex) var pTag = document.createElement(“p”);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;document.body.appendChild(pTag); ** document.body: HTML문서의 &lt;body&gt;요소를 객체로 표현한 예약어 Element 속성 지정 객체.표준속성 = 속성값; 객체.setAttribute(속성명, 속성값); ( 표준속성이 아니어도 가능 )12img.width = &quot;300&quot;; // 300px로 넣으면 안됨, px기본으로정해져있음img.setAttribute(&quot;height&quot;, &quot;150&quot;); Element 속성 얻기 객체.표준속성; 객체.getAttribute(속성명); innerHTML (property) 객체.innerHTML = “HTML 양식 문장” : 객체의 자식요소로 HTML 문장이 추가됨1234document.body.innerHTML += &quot;&lt;div&gt;&lt;h1&gt;INNER HTML&lt;/h1&gt;&lt;/div&gt;&quot;// innerHTML 에// = 연산자를 사용하면 기존의 HTML코드를 지워버림// += 연산자를 사용하면 기존코드에 추가한다 Element 객체 얻기 document.getElementById(아이디); document.getElementsByName(name속성값); document.getElementsByTagName(태그);1234567var content = document.getElementById(&quot;content&quot;);content.innerHTML += &quot;&lt;h3&gt;innerHTML&lt;/h3&gt;&quot; + &quot;&lt;p&gt;테스트&lt;/p&gt;&quot; + &quot;&lt;hr&gt;&quot;;//----------------------------------------var h3 = document.getElementsByTagName(&quot;h3&quot;);h3[1].innerHTML = &quot;HI&quot;;h3[2].innerHTML = &quot;Hello&quot;; Element 객체 제거 객체.remove() : 해당 객체 제거 객체.removeChild(node) : 객체의 자식노드 node를 제거","categories":[{"name":"Programing","slug":"Programing","permalink":"http://yoursite.com/categories/Programing/"},{"name":"Javascript","slug":"Programing/Javascript","permalink":"http://yoursite.com/categories/Programing/Javascript/"}],"tags":[]},{"title":"DOM 정리","slug":"dom","date":"2018-09-05T08:06:32.000Z","updated":"2018-09-13T08:18:16.303Z","comments":true,"path":"2018/09/05/dom/","link":"","permalink":"http://yoursite.com/2018/09/05/dom/","excerpt":"","text":"DOM, Document Object Model– 문서 객체 모델– document 내장객체를 뜻한다– HTML 문서의 태그– &lt;body&gt; 태그 내 요소들의 계층구조 == DOM– HTML문서의 요소(태그)들을 자바스크립트 코드로 접근하고 관리하기 위한 인터페이스 관련 용어 요소(Element) : HTML문서 내의 태그 문서 객체(Document Object) : 자바스크립트로 요소에 접근할 수 있도록 객체화 한 것 HTML요소와 자바스크립트의 연결 지점(인터페이스) DOM 트리 : 문서 객체를 트리구조(계층구조)로 표현한 것 노드, Node : DOM 트리 구성 요소 &nbsp;– 요소 노드: 태그 요소 &nbsp;– 텍스트 노드: 태그 요소가 감싸고 있는 텍스트 ex) &lt;h1> Hello &lt;/h1>&nbsp;&nbsp;&nbsp;&nbsp; : &lt;h1> - 요소 노드, “Hello” - 텍스트 노드 DOM 객체를 사용하는 코드의 적용 위치 &lt;head>태그 내 &lt;script>태그에서 window.onload 의 리스너로 작성 12345&lt;script&gt;window.onload = function()&#123; document.getElementById(&quot;id&quot;);&#125;;&lt;/script&gt; &lt;/body> 닫는 태그 바로 위에 &lt;script>태그에서 작성 (window.onload 필요 없음) 일반 함수에서 사용하고 해당 함수를 태그의 이벤트 리스너로 작성 ** DOM객체는 &lt;body>의 계층구조를 모두 확인하고 DOM트리가 완성된 이후에 사용해야 한다.** DOM트리가 완료되는 시점까지 DOM객체를 사용하는 코드가 실행되는 것을 미뤄야 한다.","categories":[{"name":"Programing","slug":"Programing","permalink":"http://yoursite.com/categories/Programing/"},{"name":"Javascript","slug":"Programing/Javascript","permalink":"http://yoursite.com/categories/Programing/Javascript/"}],"tags":[]},{"title":"자바스크립트 핵심 요소 4가지","slug":"js-element","date":"2018-09-03T07:57:14.000Z","updated":"2018-09-13T08:05:37.217Z","comments":true,"path":"2018/09/03/js-element/","link":"","permalink":"http://yoursite.com/2018/09/03/js-element/","excerpt":"","text":"자바스크립트 핵심 요소 4가지 자바스크립트 Core 문법 기본 문법 데이터 타입, 변수, 제어문, 함수, … 클래스, 객체, … 내장 객체(Core Library)(built-in) String, Date, Math, Array, Number, Object, … BOM, Browser Object Model, 브라우저 객체 모델 웹 브라우저 창(윈도우)과 자바스크립트가 통신하기 위한 수단으로 제공되는 객체들 – window객체 브라우저 전반적인 기능 제어 자바스크립트에서 정의한 모든 전역 변수, 함수, 객체들은 window객체의 멤버로 추가된다 ( 전역 변수 var num; -&gt; window.num = 1; 으로 사용 : window는 생략 가능해서 그냥 num = 1; 으로 사용하는 것) Javacript 최상위 객체 – navigator객체 브라우저의 정보와 운영체제의 정보를 제공하는 객체 – location객체 URL과 관련된 인터넷 주소 정보 관련 객체 – history객체 사용자 방문기록 관련 객체 – document객체 웹페이지 문서 관련 객체 –screen객체 사용자 모니터 정보 관련 객체 DOM, Document Object Model, 문서 객체 모델 (별도 정리) Event (별도 정리)","categories":[{"name":"Programing","slug":"Programing","permalink":"http://yoursite.com/categories/Programing/"},{"name":"Javascript","slug":"Programing/Javascript","permalink":"http://yoursite.com/categories/Programing/Javascript/"}],"tags":[]},{"title":"JS 데이터타입","slug":"js-datatype","date":"2018-09-02T07:43:18.000Z","updated":"2018-09-13T07:53:50.250Z","comments":true,"path":"2018/09/02/js-datatype/","link":"","permalink":"http://yoursite.com/2018/09/02/js-datatype/","excerpt":"","text":"JS 데이터타입 Number : 숫자 &nbsp;보라색 String : 문자 &nbsp;검은색 Boolean : 논리 &nbsp;파란색 Object : 객체 &nbsp;{객체} Null : null값 (참조대상 없음) undefined : 정의되지않음 Array : 배열 &nbsp;[배열요소] - NaN, Not a Number&nbsp;&nbsp;: Number타입으로 사용하려는 시점에 Number타입이 아닐 경우 리턴하는 키워드&nbsp;&nbsp;* Booolean isNaN() - NaN인지 검사하는 JS 내장 함수 - Infinity, -Infinity &nbsp;&nbsp;: 양의 무한대, 음의 무한대를 나타내는 키워드 &nbsp;&nbsp;* Boolean isFinite() - Number가 유한한 값인지 검사 - undefined &nbsp;&nbsp;: 변수가 초기화되지 않은 상태의 값 &nbsp;&nbsp;&nbsp;&nbsp;값이 할당되지 않은 상태 &nbsp;&nbsp;&nbsp;&nbsp;데이터타입조차 결정되지 않은 상태 - null&nbsp;&nbsp; : 값이 없음&nbsp;&nbsp;&nbsp;&nbsp;참조값이 없음&nbsp;&nbsp;&nbsp;&nbsp;의도적으로 값을 비워둔 상태&nbsp;&nbsp;&nbsp;&nbsp;Object 타입의 값으로 처리된다","categories":[{"name":"Programing","slug":"Programing","permalink":"http://yoursite.com/categories/Programing/"},{"name":"Javascript","slug":"Programing/Javascript","permalink":"http://yoursite.com/categories/Programing/Javascript/"}],"tags":[]},{"title":"선택자, Selector","slug":"selector","date":"2018-08-30T06:29:01.000Z","updated":"2018-09-13T07:34:51.431Z","comments":true,"path":"2018/08/30/selector/","link":"","permalink":"http://yoursite.com/2018/08/30/selector/","excerpt":"","text":"[선택자, Selector] HTML 문서에서 특정 요소를 선택하는 CSS의 문법 선택된 요소에 일괄적으로 스타일을 적용할 수 있다 [선택자 종류] 전체 선택자 : 모든 요소 \\* { }` 태그 선택자 tagName{ } 아이디 선택자 #idName{ } 클래스 선택자 .className{ } 복합 선택자 두 개 이상의 요소가 모인 선택자 요소들의 관계(계층구조)를 따져 선택한다 1.&nbsp;하위(자손) 선택자(descendant): 아래에 있는 모든 요소들E F : E의 하위 요소인 F를 선택 ex) p .blue { } &nbsp;&nbsp;/* p 태그의 자손요소 중 class가 blue인 요소들*/ (* p.blue { } &nbsp;&nbsp;/* (p와 .사이에 띄어쓰기가 없는 경우) p요소 중 class가 blue인 요소들 */ )2.&nbsp;자식 선택자(child): 바로 아래에 있는 요소 E &gt; F : E의 자식 요소 F 선택 3.&nbsp;형제 선택자(sibling) E + F : E의 인접형제 F ( E요소 바로 뒤에오는 F 요소)E ~ F : E의 일반형제 F ( E요소 뒤따르는 모든 F요소) 속성 선택자 요소의 속성(Attribute)을 이용하여 선택한다 E[attr] : attr속성을 가지고 있는 E태그 E[attr=”val”] : attr속성의 값이 val과 같은 E태그 (ex. h1[class=”abc”] ) E[attr~=”val”] : val을 완전포함하는 E태그 E[attr^=”val”] : val로 시작하는 E태그 E[attr$=”val”] : val로 끝나는 E태그 E[attr*=”val”] : val을 부분포함하는 E태그 E[attr|=”val”] : “val”과 같거나 “val-“로 시작하는 E태그 가상 선택자, pseudo selector, 의사 선택자 HTML 문서에는 실제로 존재하지 않는 요소를 선택 이벤트 기반으로 선택하거나 특정 순서에 의해 선택한다 1.&nbsp;가상 클래스 선택자 (이벤트 기반 선택자)&nbsp;&nbsp;&nbsp;E:hover - onenter, onleave 이벤트(마우스 이벤트)에 반응 &nbsp;&nbsp;&nbsp;E:active - onclick에 반응 &nbsp;&nbsp;&nbsp;E:link - &lt;a>의 방문 전 상태 &nbsp;&nbsp;&nbsp;E:visited - &lt;a>의 방문 후 상태 &nbsp;&nbsp;&nbsp;E:enabled - enable 상태인 요소 &nbsp;&nbsp;&nbsp;E:disabled - disable 상태인 요소 ex) 버튼 비활성화 상태 &nbsp;&nbsp;&nbsp;E:checked - 체크 상태인 요소 &nbsp;&nbsp;&nbsp;E:empty - 비어있는 요소 &nbsp;&nbsp;&nbsp;E:focus - 포커스 가지고 있는 요소 2.&nbsp;가상 요소 선택자&nbsp;&nbsp;&nbsp;::before - 대상요소의 앞 &nbsp;&nbsp;&nbsp;::after - 대상요소의 뒤 &nbsp;&nbsp;&nbsp;::first-line - 요소의 첫 줄 &nbsp;&nbsp;&nbsp;::first-letter - 요소의 첫 글자 3.&nbsp;요소 순서 선택자(가상 클래스에 포함됨) &nbsp;&nbsp;&nbsp;:root - 문서의 최상위 요소 ( &lt;html> ) &nbsp;&nbsp;&nbsp;:nth-child(n) - 앞에서 n번째 요소 &nbsp;&nbsp;&nbsp;:nth-last-child(n) - 뒤에서 n번째 요소 &nbsp;&nbsp;&nbsp;:first-child - 첫 요소 &nbsp;&nbsp;&nbsp;:last-child - 마지막 요소 &nbsp;&nbsp;&nbsp;:only-child - 유일한 자식 (형제요소가 없을 때) &nbsp;&nbsp;&nbsp;:only-of-type - 유일한 타입 (형제요소가 있어도) 부정 선택자 E:not(S) - S조건을 만족하지 않는 E요소 ( S는 Selector )","categories":[{"name":"Programing","slug":"Programing","permalink":"http://yoursite.com/categories/Programing/"},{"name":"CSS","slug":"Programing/CSS","permalink":"http://yoursite.com/categories/Programing/CSS/"}],"tags":[]},{"title":"id, class 속성","slug":"id-class","date":"2018-08-29T07:29:56.000Z","updated":"2018-09-13T07:38:13.110Z","comments":true,"path":"2018/08/29/id-class/","link":"","permalink":"http://yoursite.com/2018/08/29/id-class/","excerpt":"","text":"####id, class 속성 id 속성 ( id=”idName”, #idName )HTML 문서에서 각 요소들을 구분하기 위한 목적으로 사용하는 속성값주로 해당 요소에 기능(이벤트)을 부여할 때 사용한다 class 속성 ( class=”className1 className2”, .className )HTML 문서에서 공통적인 기능(스타일)을 수행해야하는 요소들을 그룹화하여 관리할 때 사용하는 속성 -&gt; 같은 스타일을 여러 요소에 적용-&gt; 같은 이벤트를 여러 요소에 적용 여러 개의 클래스값을 띄어쓰기로 구분해서 부여할 수 있다 ** ID는 웹 브라우저가 참조값을 저장해놔서 적용 속도가 빠르다.CLASS 는 따로 저장해놓지 않아서 문서를 다시 처음부터 읽으면서 CLASS요소들을 찾고 적용해준다.그래서 CLASS가 너무 많거나 구조가 복잡해지면 속도가 느려진다.","categories":[{"name":"Programing","slug":"Programing","permalink":"http://yoursite.com/categories/Programing/"},{"name":"CSS","slug":"Programing/CSS","permalink":"http://yoursite.com/categories/Programing/CSS/"}],"tags":[]},{"title":"이클립스 한글 인코딩(UTF-8) 환경 설정","slug":"setting-encode","date":"2018-08-27T14:58:04.000Z","updated":"2018-08-29T15:04:27.249Z","comments":true,"path":"2018/08/27/setting-encode/","link":"","permalink":"http://yoursite.com/2018/08/27/setting-encode/","excerpt":"","text":"웹에서는 EUC-KR 이나 UTF-8을 많이 사용한다. Window - Preferences 선택 후 General 항목- Workspace 항목- 하단의 Text file encoding의&nbsp;&nbsp;&nbsp;&nbsp;Other: UTF-8 설정 Web 항목- CSS Files- HTML Files- JSP FIles세가지 항목 모두 ISO 10646/Unicode(UTF-8) 로 설정 위와같이 1,2 설정을 해준다.","categories":[{"name":"Programing","slug":"Programing","permalink":"http://yoursite.com/categories/Programing/"}],"tags":[]},{"title":"HTML 파일명의 대소문자만 바꾸는 경우","slug":"filename-case","date":"2018-08-27T14:52:40.000Z","updated":"2018-08-29T14:56:23.521Z","comments":true,"path":"2018/08/27/filename-case/","link":"","permalink":"http://yoursite.com/2018/08/27/filename-case/","excerpt":"","text":"※ 사소주의톰캣의 배포과정에서는 대소문자 구분을 하지않기 때문에 단순히 대소문자만 바꿔서 저장하면 인식을 못하는 경우가 있다.(파일을 못찾음)배포할때 이미 파일이 존재한다고 인지해서 바뀐 파일명에 대한 파일을 처리해주지 않는다.하지만 인식과정에서는 대소문자 구분을 해주기 때문에 당연히 해당 파일이 존재하지 않는다고 처리된다. -&gt; 해결방법: 다른 문자 추가해서 바꿨다가 다시 대소문자 바꾼 파일명으로 2번에 걸친 과정으로 바꿔준다.","categories":[{"name":"Programing","slug":"Programing","permalink":"http://yoursite.com/categories/Programing/"},{"name":"Web","slug":"Programing/Web","permalink":"http://yoursite.com/categories/Programing/Web/"}],"tags":[]},{"title":"Dynamic Web Project와 서버 연결하기","slug":"web-modules","date":"2018-08-27T14:01:41.000Z","updated":"2018-09-19T06:27:25.508Z","comments":true,"path":"2018/08/27/web-modules/","link":"","permalink":"http://yoursite.com/2018/08/27/web-modules/","excerpt":"","text":"Dynamic Web Project를 서버에서 실행시키기 위해서 서버와 프로젝트를 연결시켜줘야 한다. 방법1. Server 뷰에서 원하는 톰캣 서버를 우클릭하여 ‘Add and Remove’ 을 누른다. 후에 원하는 프로젝트를 ‘Add’ 해준다. (Front라는 이름의 프로젝트이다.) 방법2.Server 뷰에서 원하는 톰캣 서버를 더블클릭한다.노란색 박스로 표시된 ‘Add Web Module…’을 클릭하면 위와 같은 창이 뜬다. * Document Base: 실제 파일이 저장된 경로* Path: 논리적인 URL 에서 인정되는 경로 브라우저에서 Path에 작성해놓은 경로를 치면 Document Base에 작성된 프로젝트 안에서 파일을 찾는다.ex) Path 를 /lala 로 해놓았고 Front라는 프로젝트의 hi.html을 로드하려면,웹 브라우저의 url에 localhost:port번호/lala/hi.html 라고 작성하면 된다. 방법1로 추가시켰을 경우에는 Path가 자동으로 Document Base와 똑같이 설정된다. * Modules 설정 변경했으면, 서버를 재실행 시켜줘야한다. 추가만들어진 Web Project 폴더의 ‘Java Resource -&gt; Libraries’ 설명 Apache Tomcat v9.0 -&gt; 톰캣 런타임. java EE 스펙이 들어가 있다. JRE System Library -&gt; 기본 java 프로그래밍 라이브러리. java se스펙이 들어가있다. 프로젝트 오른쪽 클릭 - Build path : 실행환경 설정해주는 곳","categories":[{"name":"Programing","slug":"Programing","permalink":"http://yoursite.com/categories/Programing/"},{"name":"Web","slug":"Programing/Web","permalink":"http://yoursite.com/categories/Programing/Web/"}],"tags":[]},{"title":"톰캣 설치 및 적용","slug":"install-tomcat","date":"2018-08-27T12:45:43.000Z","updated":"2018-08-29T13:49:00.787Z","comments":true,"path":"2018/08/27/install-tomcat/","link":"","permalink":"http://yoursite.com/2018/08/27/install-tomcat/","excerpt":"","text":"톰캣 서버를 설치하고 이클립스에 올려 실행하고자 한다.기존에 이클립스를 Standard 버전을 쓰고 있었는데 해당 버전은 웹 프로젝트에 대한 지원이 안되기 때문에 톰캣 설치에 앞서 우선 이클립스 EE 버전을 새로 설치하려고 한다. Eclipse IDE for Java EE Developers 다운로드-&gt; 오른쪽 위에 ! 가 떠 있으면 선택해서 update 진행 (설치 후 installer 종료하면 update 다시 해야 함)-&gt; ! 사라지면 EE 버전 다운로드 진행 나는 SE 버전을 설치한지 몇 달 됐기 때문에 그 사이에 업데이트 사항이 생겨서..이 과정을 해줘야 했다. 이제 톰켓 웹 서버를 다운받아보자. 톰켓 웹 서버 다운로드http://tomcat.apache.org/- 왼쪽 Download 항목에서 Tomcat 9 클릭- 아래쪽 9.0.11 항목에서 Core: &nbsp;&nbsp;&nbsp;&nbsp;64-bit Windows zip 클릭해서 다운 윈도우에 올려서 사용하는게 아니라 이클립스에 올려서 사용할 예정이다.그러므로 톰캣 다운받을 때 ZIP 파일로 받아야한다. (WINDOW INSTALLER 이 아닌) 이제 마지막으로 다운 받은 톰캣을 이클립스에 올려보자. 이클립스에 Server Runtime 추가Window 메뉴- Preferences 항목&nbsp;&nbsp;&nbsp;&nbsp;- Server 항목&nbsp;&nbsp;&nbsp;&nbsp;- Runtime Environments&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- Add… 버튼 클릭&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- Apache Tomcat v9.0 선택&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- Browser 버튼 -&gt; 압축해제한 Tomcat Directory 선택하고 완료 해당 톰캣 폴더가 이클립스 내부 폴더로 복사됨서버가 설치된게 아니라 서버를 만들 수 있는 환경(서버 실행 환경)이 구축된 것이다. 이제 New -&gt; Server -&gt; Tomcat v9.0 Server 을 선택해 완료하면 하나의 서버가 만들어진다!","categories":[{"name":"Programing","slug":"Programing","permalink":"http://yoursite.com/categories/Programing/"},{"name":"Web","slug":"Programing/Web","permalink":"http://yoursite.com/categories/Programing/Web/"}],"tags":[{"name":"Tomcat","slug":"Tomcat","permalink":"http://yoursite.com/tags/Tomcat/"}]},{"title":"Singleton Pattern을 이용한 Ojdbc 활용 예제","slug":"jdbcEx-singleton-180823","date":"2018-08-23T05:16:56.000Z","updated":"2018-09-19T06:43:58.139Z","comments":true,"path":"2018/08/23/jdbcEx-singleton-180823/","link":"","permalink":"http://yoursite.com/2018/08/23/jdbcEx-singleton-180823/","excerpt":"","text":"이전 포스팅에서 DTO, DAO를 이용하여 Ojdbc를 활용한 DB작업을 했었다. 아래는 이전 포스팅의 UserDaoImpl 클래스 생성자의 한 부분이다. UserDaoImpl.java1234// 드라이버 로드Class.forName(DRIVER);// DB 연결conn = DriverManager.getConnection(URL, USERNAME, PASSWORD); 만약 여러 DAO 클래스를 작성한다면,위의 코드가(DB 연결객체 생성 코드) 계속 중복해서 쓰이기 때문에 DAO 클래스의 개수만큼 DB와의 연결이 수립된다.-&gt; 싱글톤 패턴으로 해결한다 우선 DB 연결객체를 싱글톤으로 사용할 수 있도록 따로 클래스를 만들어 준다. DBConn.java12345678910111213141516171819202122232425262728293031323334353637383940package dbutil;import java.sql.Connection;import java.sql.DriverManager;import java.sql.SQLException;public class DBConn &#123; // DB 연결 정보 public static final String DRIVER = \"oracle.jdbc.driver.OracleDriver\"; public static final String URL = \"jdbc:oracle:thin:@localhost:1521:xe\"; public static final String USERNAME = \"scott\"; public static final String PASSWORD = \"tiger\"; // DB 연결객체 private static Connection conn = null; // private 생성자 - 외부생성 불가 private DBConn()&#123; &#125; // Connection 객체 반환 = Singleton Pattern public static Connection getConnection() &#123; // DB 연결이 안되어있을 때만 동작 // getInstance()를 호출할 때까지 객체생성을 미룸 if (conn == null) &#123; try &#123; Class.forName(DRIVER); //드라이버 로드 // DB 연결객체 생성 conn = DriverManager.getConnection(URL, USERNAME, PASSWORD); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; return conn; &#125;&#125; 이제 아래의 클래스처럼 객체를 싱글톤으로 얻어 사용하면 된다. UserDaoImpl2.java1234567891011public class UserDaoImpl2 implements UserDao&#123; // DB 연결 객체 -&gt; 싱글톤 private static Connection conn = DBConn.getConnection(); // JDBC 객체 private PreparedStatement ps; private ResultSet rs; // ...(생략)...&#125;","categories":[{"name":"Programing","slug":"Programing","permalink":"http://yoursite.com/categories/Programing/"},{"name":"JDBC","slug":"Programing/JDBC","permalink":"http://yoursite.com/categories/Programing/JDBC/"}],"tags":[{"name":"Singleton","slug":"Singleton","permalink":"http://yoursite.com/tags/Singleton/"}]},{"title":"싱글톤 패턴이란?","slug":"singletonPattern","date":"2018-08-23T04:07:37.000Z","updated":"2018-08-31T16:02:17.066Z","comments":true,"path":"2018/08/23/singletonPattern/","link":"","permalink":"http://yoursite.com/2018/08/23/singletonPattern/","excerpt":"","text":"디자인 패턴, Design Pattern 잘 알려진 알고리즘의 형태 프로그램 설계 상 발생하는 문제(issue)에 대한 해답을 문서화한것 프로그램을 개발하면서 자주 마주치는 상황(문제점)을 해결하기 위한 설계 노하우를 적용시킨 형태의 알고리즘들 싱글톤 패턴, Singleton 객체를 여러 번 생성하더라도 하나의 인스턴스가 유지되도록 고안한 패턴 최초 객체생성(인스턴스화, new 객체()) 이후 생성자를 호출하더라도 최초에 만들어진 인스턴스를 반환하도록 설계한다 싱글톤 패턴 적용 위치 리소스를 많이 먹는 자원을 로드할 때 어플리케이션에서 지속적으로 사용하는 자원을 로드할 때 ( 드라이버로드, OJDBC 로드)( DB Connection )( 로그(Log) 객체 ) &lt;싱글톤 패턴의 장점&gt; 객체의 로딩 시간이 빨라진다 (단, 첫번째는 빠르지 않다) 인스턴스가 프로그램 실행 중 절대적으로 한 개만 존재한다 &lt;싱글톤 패턴의 단점&gt; 싱글톤 인스턴스가 너무 많은 곳에서 사용되거나 너무 많은 데이터를 공유해주는 경우 인스턴스 들의 결합도가 높아진다. ** 개방 - 폐쇄 원칙 (객체지향 설계 원칙 중 한가지) : 응집도는 높히고/ 결합도는 낮춘다.","categories":[{"name":"Programing","slug":"Programing","permalink":"http://yoursite.com/categories/Programing/"}],"tags":[]},{"title":"static 블록","slug":"static-block","date":"2018-08-23T03:31:33.000Z","updated":"2018-08-31T16:01:50.097Z","comments":true,"path":"2018/08/23/static-block/","link":"","permalink":"http://yoursite.com/2018/08/23/static-block/","excerpt":"","text":"static 블록, 초기화 블록, Initialization Block 클래스 코드가 처음 로드될 때 딱 한번만 수행하는 코드 블록 객체생성(인스턴스화, 생성자호출)과는 무관하게 한번 수행한다(사전 준비작업단계에서 수행) 클래스변수( =정적변수 =static 변수) 초기화에 사용됨 단순 초기화(값 대입)가 아닌 예외처리같은 추가작업을 코드로 적을 수 있게 해준다 (참고)클래스로드 및 객체 생성 순서 클래스로드 (클래스 로더(JVM에 존재)가 수행) (메모리 영역 중 클래스 영역에 로드) 클래스변수 생성 static 블록 수행 ———— 로드 완료 ————(이후에는 동적인 영역) 이후 준비(로드)된 클래스의 생성자 호출을 통해 인스턴스를 생성 클래스 로더의 수행 절차 바이트 코드를 분석 프로그램에서 사용된 클래스를 JRE 라이브러리에서 .class 파일로 찾기 (ex&gt; System.out.print 인 경우 System 이라는 클래스 파일을 JRE 라이브러리에서 찾음) 없으면 CLASSPATH로 지정된 폴더에서 .class 찾기 찾은 이후, 문법검사 (올바른 문법의 바이트코드인지 검증) 올바른 문법이면, .class 파일을 메모리로 로드 클래스 블록(정적필드, 정적메소드) 처리 static 초기화 블록 수행 준비 작업이 끝나면 모두 메모리에 로드되어 있음. (미리 어디있는지 다 찾아서 연결점을 만들어 놓는다고 생각)이후 main 메소드를 한 줄씩 읽으며 실행한다.","categories":[{"name":"Programing","slug":"Programing","permalink":"http://yoursite.com/categories/Programing/"}],"tags":[]},{"title":"DAO를 이용한 Ojdbc 활용 예제(USER)","slug":"jdbcEx-user-180822","date":"2018-08-23T03:26:42.000Z","updated":"2018-09-19T06:43:54.465Z","comments":true,"path":"2018/08/23/jdbcEx-user-180822/","link":"","permalink":"http://yoursite.com/2018/08/23/jdbcEx-user-180822/","excerpt":"","text":"JDBC를 이용해 USERTEST테이블에 접근하여 몇 가지 쿼리를 수행한다. (UserDao 클래스 참고) 이전 포스팅의 예제에서는 main 함수가 있는 클래스에 DB 연결, SQL 문 수행 등 모든 작업이 한 번에 이루어 졌었다.이번에는 DAO를 이용하여 코드를 작성하였다.메인 함수 실행부와 DB 연결 및 SQL작성부를 분리시킨다. * DAO: 데이터베이스에 수행할 SQL 문을 하나의 메소드의 기능으로 구현하여 모아놓은 객체 [패키지 구성] user ├ dao │ ├ UserDao.java (인터페이스) │ └ UserDaoImpl.java │ ├ dto │ └ User.java └ ex &nbsp;&nbsp;&nbsp;&nbsp;└ UserEx.java UserDao 인터페이스12345678910111213141516171819202122package user.dao;import java.util.List;import user.dto.User;public interface UserDao &#123; //UserTest 테이블 전체 조회 // idx 정렬 public List&lt;User&gt; selectAll(); // idx를 이용한 UserTest 조회 // 1명이 조회되도록 한다 public User selectByIdx(int idx); // User 삽입 public void insertUser(User insertUser); // idx를 이용한 UserTest 삭제 public void deleteByIdx(int idx);&#125; UserDaoImpl.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187package user.dao;import java.sql.Connection;import java.sql.DriverManager;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;import java.util.ArrayList;import java.util.List;import user.dto.User;public class UserDaoImpl implements UserDao&#123; // DB 연결 정보 private final String DRIVER = \"oracle.jdbc.driver.OracleDriver\"; private final String URL = \"jdbc:oracle:thin:@localhost:1521:xe\"; private final String USERNAME = \"scott\"; private final String PASSWORD = \"tiger\"; // DB 연결 객체 private Connection conn; // JDBC 객체 private PreparedStatement ps; private ResultSet rs; public UserDaoImpl() &#123; try &#123; // 드라이버 로드 Class.forName(DRIVER); conn = DriverManager.getConnection(URL, USERNAME, PASSWORD); // 오토커밋 설정(기본값 : true) // 오토커밋 시 중간에 에러나서 프로그램종료되면 자동커밋, 데이터 깨질 수 있음 conn.setAutoCommit(false); // 이러면 commit, rollback 관리를 명시적으로 해줘야함 &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; @Override public List&lt;User&gt; selectAll() &#123; String sql = \"SELECT * FROM userTest ORDER BY idx\"; List&lt;User&gt; userList = new ArrayList&lt;&gt;(); try &#123; ps = conn.prepareStatement(sql); rs = ps.executeQuery(); while(rs.next()) &#123; User user = new User(); user.setIdx(rs.getInt(\"idx\")); user.setUserid(rs.getString(\"userid\")); user.setName(rs.getString(\"name\")); userList.add(user); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; rs.close(); ps.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; return userList; &#125; @Override public User selectByIdx(int idx) &#123; String sql = \"SELECT * FROM userTest WHERE idx = ?\"; User user = null; try &#123; ps = conn.prepareStatement(sql); ps.setInt(1, idx); rs = ps.executeQuery(); user = new User(); if(rs.next()) &#123; user.setIdx(rs.getInt(\"idx\")); user.setName(rs.getString(\"name\")); user.setUserid(rs.getString(\"userid\")); &#125; else &#123; System.out.println(\"** 조회: 해당 IDX에 해당하는 유저가 없습니다.\"); return null; &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; rs.close(); ps.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; return user; &#125; @Override public void insertUser(User insertUser) &#123; String userId = insertUser.getUserid(); String userName = insertUser.getName(); String sql = \"INSERT INTO userTest(idx, userid, name) VALUES (userTest_SQ.nextval,?,?)\"; String sql2 = \"SELECT COUNT(*) FROM userTest WHERE userid = upper(?)\"; try &#123; // 중복 아이디 체크 PreparedStatement ps2 = conn.prepareStatement(sql2); ps2.setString(1, userId); rs = ps2.executeQuery(); rs.next(); // 해당 아이디가 있다면 추가 X if(rs.getInt(1) &gt; 0) &#123; System.out.println(\"** 삽입: 같은 ID 가 존재합니다.\"); &#125; else &#123; // user 추가 ps = conn.prepareStatement(sql); ps.setString(1, userId); ps.setString(2, userName); ps.executeUpdate(); &#125; conn.commit(); // 명시적으로 커밋하기 &#125; catch (SQLException e) &#123; e.printStackTrace(); try &#123; conn.rollback(); // 예외 발생 시 롤백 &#125; catch (SQLException e1) &#123; e1.printStackTrace(); &#125; &#125; finally &#123; try &#123; rs.close(); ps.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; @Override public void deleteByIdx(int idx) &#123; String sql = \"DELETE userTest WHERE idx = ?\"; try &#123; ps = conn.prepareStatement(sql); ps.setInt(1, idx); if( ps.executeUpdate() == 0) &#123; System.out.println(\"** 삭제: 해당 IDX에 해당하는 유저가 없습니다.\"); &#125; conn.commit(); // 명시적으로 커밋하기 &#125; catch (SQLException e) &#123; e.printStackTrace(); try &#123; conn.rollback(); // 예외 발생 시 롤백 &#125; catch (SQLException e1) &#123; e1.printStackTrace(); &#125; &#125; finally &#123; try &#123; ps.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; ** 메소드 안의 catch문에서 자원 해제할 때 conn은 close()하면 안된다. 연결 객체를 해제해버리면 다른 메소드에서 접근 할 수 없다.","categories":[{"name":"Programing","slug":"Programing","permalink":"http://yoursite.com/categories/Programing/"},{"name":"JDBC","slug":"Programing/JDBC","permalink":"http://yoursite.com/categories/Programing/JDBC/"}],"tags":[]},{"title":"코드블럭 스타일 바꾸기","slug":"codeBlockSpace","date":"2018-08-23T01:17:45.000Z","updated":"2018-08-29T15:14:48.897Z","comments":true,"path":"2018/08/23/codeBlockSpace/","link":"","permalink":"http://yoursite.com/2018/08/23/codeBlockSpace/","excerpt":"","text":"코드블럭의 탭 간격 바꾸기_config.yml 파일에서12highlight: tab_replace: &apos; &apos; tab_replace:에 원하는 만큼의 간격을 넣어준다. 간단하게 바꿀 수 있는 거였는데, 별로의 css 파일을 수정하거나 플러그인을 따로 설치하는건가 싶어 엄청 헤맸다.. 코드블럭의 하이라이트 스타일 바꾸기현재 HUEMAN 테마를 사용 중이다. themes\\hueman\\_config.yml 파일을 열어12customize: highlight: highlight: 에 원하는 스타일명을 넣어주면 된다. 바꿔주려는 명은 css\\highlight에 존재하는 파일명중 하나로 바꿔주면 된다.","categories":[],"tags":[]},{"title":"PreparedStatement을 이용한 Ojdbc 사용 예제","slug":"jdbcEx-180821","date":"2018-08-22T14:23:12.000Z","updated":"2018-09-19T06:44:02.331Z","comments":true,"path":"2018/08/22/jdbcEx-180821/","link":"","permalink":"http://yoursite.com/2018/08/22/jdbcEx-180821/","excerpt":"","text":"DB의 emp 테이블에서 job = ‘SALESMAN’ 인 컬럼들을 조회하여 출력한다.출력 시 Emp 클래스를 이용하여 출력한다. Emp는 DTO클래스로 따로 만들었다. (사용 필드, toString, getter/setter) ※ PreparedStatement 사용 : 더 안전하고 활용도 큼 -&gt; Statement 대신 이걸로 쓰기! 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485package ojdbc;import java.sql.Connection;import java.sql.DriverManager;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;import java.util.ArrayList;import java.util.List;import dto.Emp;public class OjdbcEx_04 &#123; // OJDBC DRIVER private static final String DRIVER = \"oracle.jdbc.driver.OracleDriver\"; // DB 연결 정보 private static final String URL = \"jdbc:oracle:thin:@localhost:1521:xe\"; private static final String USERNAME = \"scott\"; private static final String PASSWORD = \"tiger\"; // OJDBC 객체 private static Connection conn; // DB 연결객체 private static PreparedStatement ps; // SQL 수행객체 private static ResultSet rs; // 조회결과 public static void main(String[] args) &#123; try &#123; // 드라이버 로드 Class.forName(DRIVER); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; // ?없어도 PreparedStatement 사용가능 String sql = \"SELECT * FROM emp WHERE job = ? ORDER BY empno\"; try &#123; conn = DriverManager.getConnection(URL, USERNAME, PASSWORD); ps = conn.prepareStatement(sql); // SQL의 첫번째 ? 에 데이터를 넣는다 ps.setString(1, \"SALESMAN\"); // SQL 쿼리 수행 rs = ps.executeQuery(); // 쿼리 결과를 담은 List List&lt;Emp&gt; list = new ArrayList&lt;&gt;(); // 쿼리 결과 list 에 담기 while(rs.next()) &#123; //데이터가 없으면 false // 매번 emp 객체 생성해서 해당 객체를 list 에 넣는다 Emp emp = new Emp(); emp.setEmpno(rs.getInt(\"empno\")); emp.setEname(rs.getString(\"ename\")); emp.setJob(rs.getString(\"job\")); emp.setMgr(rs.getInt(\"mgr\")); emp.setHiredate(rs.getDate(\"hiredate\")); emp.setSal(rs.getInt(\"sal\")); emp.setComm(rs.getInt(\"comm\")); emp.setDeptno(rs.getInt(\"deptno\")); list.add(emp); &#125; // 쿼리 결과 출력 for( Emp e : list) &#123; System.out.println(e); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; rs.close(); ps.close(); conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; ** 드라이버 로드해주는 코드는 ojdbc4.jar 인가 ojdbc6.jar 부터는 자동으로 해줘서 안써도 실행은 된다고 한다.","categories":[{"name":"Programing","slug":"Programing","permalink":"http://yoursite.com/categories/Programing/"},{"name":"JDBC","slug":"Programing/JDBC","permalink":"http://yoursite.com/categories/Programing/JDBC/"}],"tags":[{"name":"DAO","slug":"DAO","permalink":"http://yoursite.com/tags/DAO/"},{"name":"DTO","slug":"DTO","permalink":"http://yoursite.com/tags/DTO/"},{"name":"PreparedStatement","slug":"PreparedStatement","permalink":"http://yoursite.com/tags/PreparedStatement/"}]},{"title":"DAO & DTO","slug":"DAODTO","date":"2018-08-22T13:26:20.000Z","updated":"2018-08-22T14:38:32.903Z","comments":true,"path":"2018/08/22/DAODTO/","link":"","permalink":"http://yoursite.com/2018/08/22/DAODTO/","excerpt":"","text":"DTO, Data Transmission Object(프레임워크 단에서 주로 쓰이는 용어) 데이터 전송 객체 VO (Value Object) 계층간 데이터 교환을 위한 자바 클래스( Java Beans: , JAVA EE(EnterPrise : 웹이나 대규모 플젝할 때 쓰임, (JAVA SE (기본))) - 이쪽에서 주로 사용하는 용어) DTO 클래스 명은 테이블의 이름과 같게 하는 것이 좋다 멤버 필드는 모두 private(데이터베이스 테이블의 컬럼명과 같게 하는 것이 좋다) 메소드는 getter, setter, toString() 만 작성 ** VO : 데이터로만 이뤄진 객체 &nbsp;&nbsp;&nbsp;&nbsp;DTO : VO 랑 거의 같은 의미. 전송을 목적으로 했을 때 DTO 라고 씀 DAO, Data Access Object Database의 데이터에 접근하기 위한 객체 데이터베이스에 수행할 SQL 문을 하나의 메소드의 기능으로 구현하여 모아놓은 객체","categories":[{"name":"Programing","slug":"Programing","permalink":"http://yoursite.com/categories/Programing/"},{"name":"JDBC","slug":"Programing/JDBC","permalink":"http://yoursite.com/categories/Programing/JDBC/"}],"tags":[{"name":"DAO","slug":"DAO","permalink":"http://yoursite.com/tags/DAO/"},{"name":"DTO","slug":"DTO","permalink":"http://yoursite.com/tags/DTO/"}]}]}