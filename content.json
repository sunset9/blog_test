{"meta":{"title":"Don't forget","subtitle":"lazy","description":null,"author":"Hae Jin","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"Singleton Pattern을 이용한 Ojdbc 활용 예제 _0823","slug":"jdbcEx-singleton-180823","date":"2018-08-23T05:16:56.000Z","updated":"2018-08-23T09:54:31.610Z","comments":true,"path":"2018/08/23/jdbcEx-singleton-180823/","link":"","permalink":"http://yoursite.com/2018/08/23/jdbcEx-singleton-180823/","excerpt":"","text":"이전 포스팅에서 DTO, DAO를 이용하여 Ojdbc를 활용한 DB작업을 했었다. 아래는 이전 포스팅의 UserDaoImpl 클래스 생성자의 한 부분이다. UserDaoImpl.java1234// 드라이버 로드Class.forName(DRIVER);// DB 연결conn = DriverManager.getConnection(URL, USERNAME, PASSWORD); 만약 여러 DAO 클래스를 작성한다면,위의 코드가(DB 연결객체 생성 코드) 계속 중복해서 쓰이기 때문에 DAO 클래스의 개수만큼 DB와의 연결이 수립된다.-&gt; 싱글톤 패턴으로 해결한다 123456789101112131415161718192021222324252627282930313233343536373839package dbutil;import java.sql.Connection;import java.sql.DriverManager;import java.sql.SQLException;public class DBConn &#123; // DB 연결 정보 public static final String DRIVER = \"oracle.jdbc.driver.OracleDriver\"; public static final String URL = \"jdbc:oracle:thin:@localhost:1521:xe\"; public static final String USERNAME = \"scott\"; public static final String PASSWORD = \"tiger\"; // DB 연결객체 private static Connection conn = null; // private 생성자 private DBConn()&#123; &#125; // Connection 객체 반환 = Singleton Pattern public static Connection getConnection() &#123; // DB 연결이 안되어있을 때만 동작 if (conn == null) &#123; try &#123; Class.forName(DRIVER); //드라이버 로드 // DB 연결객체 생성 conn = DriverManager.getConnection(URL, USERNAME, PASSWORD); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; return conn; &#125;&#125; 위 처럼 DB 연결객체를 싱글톤으로 사용할 수 있도록 따로 클래스를 만들어 준다. 이제는 위의 클래스로 1234567891011public class UserDaoImpl2 implements UserDao&#123; // DB 연결 객체 -&gt; 싱글톤 private static Connection conn = DBConn.getConnection(); // JDBC 객체 private PreparedStatement ps; private ResultSet rs; // ...(생략)...&#125;","categories":[{"name":"Programing","slug":"Programing","permalink":"http://yoursite.com/categories/Programing/"},{"name":"JDBC","slug":"Programing/JDBC","permalink":"http://yoursite.com/categories/Programing/JDBC/"}],"tags":[{"name":"Singleton","slug":"Singleton","permalink":"http://yoursite.com/tags/Singleton/"}]},{"title":"Ojdbc 활용 예제(USER) _0822","slug":"jdbcEx-user-180822","date":"2018-08-23T03:26:42.000Z","updated":"2018-08-23T09:54:31.627Z","comments":true,"path":"2018/08/23/jdbcEx-user-180822/","link":"","permalink":"http://yoursite.com/2018/08/23/jdbcEx-user-180822/","excerpt":"","text":"JDBC를 이용해 USERTEST테이블에 접근하여 몇 가지 쿼리를 수행한다. 이전 포스팅의 예제에서는 main 함수가 있는 클래스에 DB 연결, SQL 문 수행 등 모든 작업이 한 번에 이루어 졌었다.이번에는 DAO를 이용하여 코드를 작성하였다. [패키지 구성] user ├ dao │ ├ UserDao.java (인터페이스) │ └ UserDaoImpl.java │ ├ dto │ └ User.java └ ex &nbsp;&nbsp;&nbsp;&nbsp;└ UserEx.java UserDao 인터페이스12345678910111213141516171819202122package user.dao;import java.util.List;import user.dto.User;public interface UserDao &#123; //UserTest 테이블 전체 조회 // idx 정렬 public List&lt;User&gt; selectAll(); // idx를 이용한 UserTest 조회 // 1명이 조회되도록 한다 public User selectByIdx(int idx); // User 삽입 public void insertUser(User insertUser); // idx를 이용한 UserTest 삭제 public void deleteByIdx(int idx); &#125; UserDaoImpl.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187package user.dao;import java.sql.Connection;import java.sql.DriverManager;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;import java.util.ArrayList;import java.util.List;import user.dto.User;public class UserDaoImpl implements UserDao&#123; // DB 연결 정보 private final String DRIVER = \"oracle.jdbc.driver.OracleDriver\"; private final String URL = \"jdbc:oracle:thin:@localhost:1521:xe\"; private final String USERNAME = \"scott\"; private final String PASSWORD = \"tiger\"; // DB 연결 객체 private Connection conn; // JDBC 객체 private PreparedStatement ps; private ResultSet rs; public UserDaoImpl() &#123; try &#123; // 드라이버 로드 Class.forName(DRIVER); conn = DriverManager.getConnection(URL, USERNAME, PASSWORD); // 오토커밋 설정(기본값 : true) // 오토커밋 시 중간에 에러나서 프로그램종료되면 자동커밋, 데이터 깨질 수 있음 conn.setAutoCommit(false); // 이러면 commit, rollback 관리를 명시적으로 해줘야함 &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; @Override public List&lt;User&gt; selectAll() &#123; String sql = \"SELECT * FROM userTest ORDER BY idx\"; List&lt;User&gt; userList = new ArrayList&lt;&gt;(); try &#123; ps = conn.prepareStatement(sql); rs = ps.executeQuery(); while(rs.next()) &#123; User user = new User(); user.setIdx(rs.getInt(\"idx\")); user.setUserid(rs.getString(\"userid\")); user.setName(rs.getString(\"name\")); userList.add(user); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; rs.close(); ps.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; return userList; &#125; @Override public User selectByIdx(int idx) &#123; String sql = \"SELECT * FROM userTest WHERE idx = ?\"; User user = null; try &#123; ps = conn.prepareStatement(sql); ps.setInt(1, idx); rs = ps.executeQuery(); user = new User(); if(rs.next()) &#123; user.setIdx(rs.getInt(\"idx\")); user.setName(rs.getString(\"name\")); user.setUserid(rs.getString(\"userid\")); &#125; else &#123; System.out.println(\"** 조회: 해당 IDX에 해당하는 유저가 없습니다.\"); return null; &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; rs.close(); ps.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; return user; &#125; @Override public void insertUser(User insertUser) &#123; String userId = insertUser.getUserid(); String userName = insertUser.getName(); String sql = \"INSERT INTO userTest(idx, userid, name) VALUES (userTest_SQ.nextval,?,?)\"; String sql2 = \"SELECT COUNT(*) FROM userTest WHERE userid = upper(?)\"; try &#123; // 중복 아이디 체크 PreparedStatement ps2 = conn.prepareStatement(sql2); ps2.setString(1, userId); rs = ps2.executeQuery(); rs.next(); // 해당 아이디가 있다면 추가 X if(rs.getInt(1) &gt; 0) &#123; System.out.println(\"** 삽입: 같은 ID 가 존재합니다.\"); &#125; else &#123; // user 추가 ps = conn.prepareStatement(sql); ps.setString(1, userId); ps.setString(2, userName); ps.executeUpdate(); &#125; conn.commit(); // 명시적으로 커밋하기 &#125; catch (SQLException e) &#123; e.printStackTrace(); try &#123; conn.rollback(); // 예외 발생 시 롤백 &#125; catch (SQLException e1) &#123; e1.printStackTrace(); &#125; &#125; finally &#123; try &#123; rs.close(); ps.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; @Override public void deleteByIdx(int idx) &#123; String sql = \"DELETE userTest WHERE idx = ?\"; try &#123; ps = conn.prepareStatement(sql); ps.setInt(1, idx); if( ps.executeUpdate() == 0) &#123; System.out.println(\"** 삭제: 해당 IDX에 해당하는 유저가 없습니다.\"); &#125; conn.commit(); // 명시적으로 커밋하기 &#125; catch (SQLException e) &#123; e.printStackTrace(); try &#123; conn.rollback(); // 예외 발생 시 롤백 &#125; catch (SQLException e1) &#123; e1.printStackTrace(); &#125; &#125; finally &#123; try &#123; ps.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; ** 메소드 안의 catch문에서 자원 해제할 때 conn.close() 는 하면 안된다. 연결 객체를 해제해버리면 다른 메소드에서 접근 할 수 없다.","categories":[{"name":"Programing","slug":"Programing","permalink":"http://yoursite.com/categories/Programing/"},{"name":"JDBC","slug":"Programing/JDBC","permalink":"http://yoursite.com/categories/Programing/JDBC/"}],"tags":[]},{"title":"코드블럭 스타일 바꾸기 (수정예정)","slug":"codeBlockSpace","date":"2018-08-23T01:17:45.000Z","updated":"2018-08-23T09:54:31.574Z","comments":true,"path":"2018/08/23/codeBlockSpace/","link":"","permalink":"http://yoursite.com/2018/08/23/codeBlockSpace/","excerpt":"","text":"코드블럭의 탭 간격 바꾸기_config.yml 파일에서12highlight: tab_replace: &apos; &apos; tab_replace 에 원하는 만큼의 간격을 넣어준다. 간단하게 바꿀 수 있는 거였는데, 별로의 스타일 파일을 넣어주거나 하는 식의 방식으로 하는 줄알고 엄청 헤맸다. 코드블럭의 하이라이트 스타일 바꾸기현재 HUEMAN 테마를 사용 중이다. themes\\hueman_config.yml 파일을 열어1highlight theme: 를 바꿔준다. 바꿔주려는 명은 css\\highlight에 존재하는 파일명중 하나로 바꿔주면 된다. 하이라이트 스타일을 바꾸는 방법은 HUEMAN공식 문서에 존재?한다.","categories":[],"tags":[]},{"title":"Ojdbc 사용 예제 _0821","slug":"jdbcEx-180821","date":"2018-08-22T14:23:12.000Z","updated":"2018-08-23T09:54:31.594Z","comments":true,"path":"2018/08/22/jdbcEx-180821/","link":"","permalink":"http://yoursite.com/2018/08/22/jdbcEx-180821/","excerpt":"","text":"DB의 emp 테이블에서 job = ‘SALESMAN’ 인 컬럼들을 조회하여 출력한다.출력 시 Emp 클래스를 이용하여 출력한다. Emp는 DTO클래스로 따로 만들었다. (사용 필드, toString, getter/setter) ※ PreparedStatement 사용 : 더 안전하고 활용도 큼 -&gt; Statement 대신 이걸로 쓰기! 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485package ojdbc;import java.sql.Connection;import java.sql.DriverManager;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;import java.util.ArrayList;import java.util.List;import dto.Emp;public class OjdbcEx_04 &#123; // OJDBC DRIVER private static final String DRIVER = \"oracle.jdbc.driver.OracleDriver\"; // DB 연결 정보 private static final String URL = \"jdbc:oracle:thin:@localhost:1521:xe\"; private static final String USERNAME = \"scott\"; private static final String PASSWORD = \"tiger\"; // OJDBC 객체 private static Connection conn; // DB 연결객체 private static PreparedStatement ps; // SQL 수행객체 private static ResultSet rs; // 조회결과 public static void main(String[] args) &#123; try &#123; // 드라이버 로드 Class.forName(DRIVER); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; // ?없어도 PreparedStatement 사용가능 String sql = \"SELECT * FROM emp WHERE job = ? ORDER BY empno\"; try &#123; conn = DriverManager.getConnection(URL, USERNAME, PASSWORD); ps = conn.prepareStatement(sql); // SQL의 첫번째 ? 에 데이터를 넣는다 ps.setString(1, \"SALESMAN\"); // SQL 쿼리 수행 rs = ps.executeQuery(); // 쿼리 결과를 담은 List List&lt;Emp&gt; list = new ArrayList&lt;&gt;(); // 쿼리 결과 list 에 담기 while(rs.next()) &#123; //데이터가 없으면 false // 매번 emp 객체 생성해서 해당 객체를 list 에 넣는다 Emp emp = new Emp(); emp.setEmpno(rs.getInt(\"empno\")); emp.setEname(rs.getString(\"ename\")); emp.setJob(rs.getString(\"job\")); emp.setMgr(rs.getInt(\"mgr\")); emp.setHiredate(rs.getDate(\"hiredate\")); emp.setSal(rs.getInt(\"sal\")); emp.setComm(rs.getInt(\"comm\")); emp.setDeptno(rs.getInt(\"deptno\")); list.add(emp); &#125; // 쿼리 결과 출력 for( Emp e : list) &#123; System.out.println(e); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; rs.close(); ps.close(); conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; ** 드라이버 로드해주는 코드는 ojdbc4.jar 인가 ojdbc6.jar 부터는 자동으로 해줘서 안써도 실행은 된다고 한다.","categories":[{"name":"Programing","slug":"Programing","permalink":"http://yoursite.com/categories/Programing/"},{"name":"JDBC","slug":"Programing/JDBC","permalink":"http://yoursite.com/categories/Programing/JDBC/"}],"tags":[{"name":"PreparedStatement","slug":"PreparedStatement","permalink":"http://yoursite.com/tags/PreparedStatement/"},{"name":"DAO","slug":"DAO","permalink":"http://yoursite.com/tags/DAO/"},{"name":"DTO","slug":"DTO","permalink":"http://yoursite.com/tags/DTO/"}]},{"title":"DAO & DTO","slug":"DAODTO","date":"2018-08-22T13:26:20.000Z","updated":"2018-08-22T14:38:32.903Z","comments":true,"path":"2018/08/22/DAODTO/","link":"","permalink":"http://yoursite.com/2018/08/22/DAODTO/","excerpt":"","text":"DTO, Data Transmission Object(프레임워크 단에서 주로 쓰이는 용어) 데이터 전송 객체 VO (Value Object) 계층간 데이터 교환을 위한 자바 클래스( Java Beans: , JAVA EE(EnterPrise : 웹이나 대규모 플젝할 때 쓰임, (JAVA SE (기본))) - 이쪽에서 주로 사용하는 용어) DTO 클래스 명은 테이블의 이름과 같게 하는 것이 좋다 멤버 필드는 모두 private(데이터베이스 테이블의 컬럼명과 같게 하는 것이 좋다) 메소드는 getter, setter, toString() 만 작성 ** VO : 데이터로만 이뤄진 객체 &nbsp;&nbsp;&nbsp;&nbsp;DTO : VO 랑 거의 같은 의미. 전송을 목적으로 했을 때 DTO 라고 씀 DAO, Data Access Object Database의 데이터에 접근하기 위한 객체 데이터베이스에 수행할 SQL 문을 하나의 메소드의 기능으로 구현하여 모아놓은 객체","categories":[{"name":"Programing","slug":"Programing","permalink":"http://yoursite.com/categories/Programing/"},{"name":"JDBC","slug":"Programing/JDBC","permalink":"http://yoursite.com/categories/Programing/JDBC/"}],"tags":[{"name":"DAO","slug":"DAO","permalink":"http://yoursite.com/tags/DAO/"},{"name":"DTO","slug":"DTO","permalink":"http://yoursite.com/tags/DTO/"}]}]}